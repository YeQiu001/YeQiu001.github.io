[{"title":"事务注解@Transactional失效的3种场景及解决办法","date":"2021-03-31T06:16:48.000Z","url":"/2021/03/31/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional%E5%A4%B1%E6%95%88%E7%9A%843%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","tags":[["Spring","/tags/Spring/"],["Annotation","/tags/Annotation/"]],"categories":[["Spring","/categories/Spring/"],["Annotation","/categories/Spring/Annotation/"],["Transactional","/categories/Spring/Annotation/Transactional/"]],"content":" 本问引用自博客： 一撸向北 一、Transactional失效场景介绍第一种&emsp;&emsp;Transactional注解标注方法修饰符为非public时，@Transactional注解将会不起作用，例如以下代码，定义一个错误的@Transactional标注实现，修饰一个默认访问符的方法 &emsp;&emsp;在同一个包内，新建调用对象，进行访问。 &emsp;&emsp;测试用例 &emsp;&emsp;以上的访问方式，导致事务没开启，因此在方法抛出异常时，testMapper.insert(new Test(10,20,30));操作不会进行回滚。如果TestServiceImpl#insertTestWrongModifier方法由default改为public的话将会正常开启事务，testMapper.insert(new Test(10,20,30));将会进行回滚。 第二种&emsp;&emsp;在类内部调用调用同一类内部@Transactional标注的方法。这种情况下也会导致事务不开启。示例代码如下，设置一个内部调用 &emsp;&emsp;测试用例 &emsp;&emsp;上面就是使用的测试代码，运行测试知道，外部调用事务方法能够征程开启事务，testMapper.insert(new Test(10,20,30))操作将会被回滚； &emsp;&emsp;然后运行另外一个测试用例，调用一个方法在类内部调用内部被@Transactional标注的事务方法，运行结果是事务不会正常开启，testMapper.insert(new Test(10,20,30))操作将会保存到数据库不会进行回滚。 第三种&emsp;emsp;事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。示例代码如下: &emsp;&emsp;测试代码如下： &emsp;&emsp;运行测试用例发现，虽然抛出异常，但是异常被捕捉了，没有抛出到方法 外， testMapper.insert(new Test(210,20,30))操作并没有回滚。 &emsp;&emsp;以上三种就是@Transactional注解不起作用，@Transactional注解失效的主要原因。下面结合spring中对于@Transactional的注解实现源码分析为何导致@Transactional注解不起作用。 二、**@Transactional注解不起作用原理分析**"},{"title":"objective","date":"2021-03-29T03:39:46.000Z","url":"/2021/03/29/objective/","tags":[["target","/tags/target/"]],"categories":[["undefined",""]],"content":"1.短期目标：第一阶段1.1 输出Spring Security 原理文档（简单讲解，后续会陆续增加详细说明，在后续目标中再确定）1.2 输出Spring Security Demo学习文档（包含简单的源码讲解）1.3 输出Spring Security核心源码学习文档1.4 学习OAuth2.0框架1.5 输出OAuth2.0原理文档…… 每日目标&emsp;&emsp;保证每日更新博客内容"},{"title":"Spring Security Demo 学习","date":"2021-03-24T16:00:00.000Z","url":"/2021/03/25/SpringSecurityDemoStudy/","tags":[["demo","/tags/demo/"],["Spring Security","/tags/Spring-Security/"],["Spring Boot","/tags/Spring-Boot/"]],"categories":[["Spring Security","/categories/Spring-Security/"],["Study","/categories/Spring-Security/Study/"],["Demo","/categories/Spring-Security/Study/Demo/"]],"content":"&emsp;&emsp;本问主要基于Spring boot框架进行Demo说明，首先创建一个Springboot 工程。 1.创建Springboot 工程2.引入Spring Security 依赖&emsp;&emsp;我们可以直接引入Spring Security 的starter包 &emsp;&emsp;当我们查看spring-boot-starter-security引入的依赖时，我们可以看到starter主要引入了Spring Security的spring-security-config和spring-security-web包，我们也可以手动引入这两个包 3.Demo学习3.1Spring Security默认配置&emsp;&emsp;我们建立的Spring boot工程默认端口号为8080，在引入Spring Security包之前，启动服务，访问;此时页面显示404，无法找到页面；此时我们在将Spring Security的依赖引入，重启服务，再次访问服务，此时我们可以看到如下页面： &emsp;&emsp;这是一个表单认证的登录页面，也就是说当引入Spring Security依赖后，服务就已经开启Spring Security的认证功能，那既然Spring Security既然引入依赖后就默认开启了认证功能，是不是就有默认的用户名和密码？其实Spring Security中有一个SecurityProperties配置类中的一个静态内部类中告诉了我们默认的用户名和密码，可以看到默认用户名和密码分别是user和uuid生成的一串随机码，此时我们只能明确一个用户名是user，密码的随机字符串我们却不知道。 &emsp;&emsp;此时我们查看这个内部类被谁调用过，是不是可以从调用处能够看到默认密码的信息，当我们查看调用方时，我们可以看到一个类名：UserDetailsServiceAutoConfiguration的类，如果认真看服务启动时打印的信息的话，可以看到控制台其实打印了这个类的信息： &emsp;&emsp;查看这个类的代码： &emsp;&emsp;在这个类的注释可以知道，这个自动配置类时记忆了一个默认的用户，在定义AuthenticationManager、AuthenticationProvider、UserDetailsService中任一类时，这个自动配置类会被禁用。&emsp;&emsp;我们可以看到在这个类的getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder)方法中通过日志的方式打印了密码的信息，那我们在看看之前截截图中打印的控制台信息，第二处标红就是上述类方法中打印的密码信息，此时我们已经知道了Spring Security在配置用户名和密码的情况下默认的用户密码为user和控制台打印出的随机码。&emsp;&emsp;此时我们再访问 ,输入默认的用户名和密码，此时点击Sign in按钮后，页面跳转依然显示404，其实Spring Security已经验证了信息，这个404是我们未定义访问的接口返回的信息或需要跳转的页面。&emsp;&emsp;我们可以定义一下访问接口的，在这之前我们先通过配置文件修改一下我们当前的用户名和密码，在配置文件中增加如下配置： &emsp;&emsp;重启服务，发现此前控制台打印的UserDetailsServiceAutoConfiguration信息和随机密码在控制台已经不打印了，此时我们在登录页输入我们配置的用户名和密码，发现效果和之前相同，但因为我们没有配置接口信息，无法确认验证是否进行及配置是否生效。&emsp;&emsp;我们在服务中建一个测试的Controller &emsp;&emsp;此时我们重启服务再去页面登录后查看效果，此时页面展示了我们接口中定义的Hello World的字符串，但此时是否说明我们Spring Security已经验证成功？还是说Spring Security没有做认证，只是提供了登录页面无论输入什么用户名和密码都会成功呢？？我们返回登录页面，输入一个错误的用户名或者密码来验证一下。&emsp;&emsp;当我们输入错误的用户名或者密码时，我们可以看到页面并未跳转且登录页面显示“用户名或密码错误”，此时可以说明Spring Security已经对我们的请求进行了简单的认证。&emsp;&emsp;但我们现在只是验证了引入了Spring Security的默认配置，但我们实际使用中需要做到Spring Security 的可配置，以适应我们项目的需求，Spring Security本身和Spring框架一样，提供了框架了可扩展性，所以后续过程中，我们就要实现的Spring Security的扩展性配置。 3.2 Spring Security 配置（简单）&emsp;&emsp;要使用Spring Security的认证和鉴权功能以满足我们的产品，我们就需要知道如何去配置Spring Security以满足我们的需求使用。&emsp;&emsp;根据Spring Security官网介绍，完成Spring Seccurity配置需要继承"},{"title":"SpringSecurity原理","date":"2021-03-02T09:07:54.000Z","url":"/2021/03/02/SpringSecurity%E5%8E%9F%E7%90%86/","tags":[["spring security","/tags/spring-security/"]],"categories":[["Spring Security","/categories/Spring-Security/"],["base","/categories/Spring-Security/base/"]],"content":"SpringSecurity原理一、SpringSecurity过滤器链 SpringSecurity的底层实现是一条过滤器链，也就是说用户进来后，由这些过滤器链判断是否有请求的权限，如果有权限则放过；没有权限的化就会抛出异常，重定向到要跳转的页面 SpringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤器链的各个进行说明:&emsp;&emsp;2.1 WebAsyncManagerIntegrationFilter：将Security上下文与Spring Web中用于处理异步请求映射的WebAsyncManager进行集成;&emsp;&emsp;2.2 SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个”仓储”中，然后将SecurityContextHolder中的信息清除，例如：在Session中维护一个用户的安全信息就是这个过滤器处理的;&emsp;&emsp;2.3HeaderWriterFilter：用于将头信息加入到响应中;&emsp;&emsp;2.4 CsrfFilter：用于处理跨站请求伪造;&emsp;&emsp;2.5 LogoutFilter：用于处理退出登录;&emsp;&emsp;2.6 UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自/login的请求。从表单中获取用户名和密码时，默认使用的name的值为username和password，这两个值可以通过设置这个过滤器的usernameParameter和passwordParameter两个参数的值进行修改。&emsp;&emsp;2.7 DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且在需要进行登陆时生成一个登录表单页面。&emsp;&emsp;2.8 BasicAuthenticationFilter：检测和处理http basic认证。&emsp;&emsp;2.9 RequestCacheAwareFilter：用来处理请求的缓存。&emsp;&emsp;2.10 SecurityContextHolderAwareRequestFilter：主要包装请求的Requeest。&emsp;&emsp;2.11 AnonymousAuthenticationFilter： 检测SecurityContextHolder中是否存在Authentication对象，如果不存在为其提供一个匿名Authentication。&emsp;&emsp;2.12 SessionManagementFilter：管理session的过滤器。&emsp;&emsp;2.13 ExceptionTranslationFilter：处理AccessDeniedException和AuthenticationException异常。&emsp;&emsp;2.14 FilterSecurityInterceptor：过滤器链的出口。&emsp;&emsp;2.15 RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时，从cookie中找出用户的信息，如果Spring Security能够识别出用户提供的remember me cookie,用户将不必填写用户名和密码，而是直接登录进入系统，该过滤器默认不开启。二、SpringSecurity流程图(如链接中流程图)&emsp;&emsp;SpringSecurity流程图 三、SpringSecurity流程说明 客户端发起请求，进入过滤器链 当到LogoutFilter的时候判断是否是登出路径，如果是登出路径则到LogoutHandler，如果登出成功则到logoutSuccessHandler登出成功处理，如果登出失败则由ExceptionTranslationFilter，如果不是登出路径则直接进入下一个过滤器。 当到UsernamePasswordAuthenticationFilter的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到AuthenticationFailureHandler登录失败处理器处理，如果登录成功则到AuthenticationSuccessHandler登录成功处理器处理，如果不是登录请求则不进入该过滤器。 当到FilterSecurityInterceptor的时候会拿到uri，根据uri去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到Controller层否则到AccessDeniedHandler鉴权失败处理器处理。四、SpringSecurity配置(简单介绍，详细使用方案会在后续使用文档中说明，本文档主要是介绍文档)&emsp;&emsp;Springboot需要在WebSecurityconfigurerAdapter这个类中实现上述流程图的配置，代码中需要实现这个类并重写其中需要使用的方法配置伪代码 配置简介&emsp;&emsp;config(AuthenticationManagerBuilder auth) 配置Security认证的方法，AuthenticationManagerBuilder见明知义，就是构建一个Authentication的管理器，该类的功能参考SpringSecurity流程图中AuthenticationManager部分所示，该部分可以配置UserDetailsService和PasswordEncoder。UserDetailsService用于在认证器中根据用户传过来的用户名查找一个用户，在使用过程中，可以实现该接口，重写其中的方法，加载一个UserDeatils信息，认证通过后就会将该对象赋给认证通过的Authentication的Principal对象，后续需要对象信息时就通过SecurityContextHolder获取存放在SecurityContext中的Authentication的principal。PasswordEncoder用于密码的加密与比对，可以自定义加密方法。&emsp;&emsp;configure(WebSecurity web) 配置静态资源的权限。&emsp;&emsp;config(HttpSecurity http) 这个配置方法是WebSecurityConfigurerAdapter的核心配置方法，每个配置我们可以分开说明。 &emsp;&emsp;此段代码配置了登录页请求路径，密码属性名，用户名属性名，和登录请求路径,permitAll()代表任意用户可访问。 ​ 此段代码是对权限的配置，这段代码表示访问/test的URL时需要有test的权限方可访问，anyRequest() 表示任意请求，authenticated()表示需要通过认证，accessDecisionManager() 表示绑定在url上的鉴权管理器。 &emsp;&emsp;用户登出时的相关配置，new MyLogoutSuccessHandler()登出成功后的处理，可自定义。 &emsp;&emsp;此段代码是关闭csrf。 &emsp;&emsp;此段代码是配置鉴权失败的处理器。 &emsp;&emsp;代码展示如何在过滤器链中插入自己的过滤器，addFilterBefore加在对应的过滤器之前，addFilterAfter加在对应的过滤器之后，addFilterAt加在过滤器同一位置，事实上框架原有的Filter在启动HttpSecurity配置的过程中，都由框架完成了其一定程度上固定的配置，是不允许更改替换的。根据测试结果来看，调用addFilterAt方法插入的Filter，会在这个位置上的原有Filter之前执行。 五、SpringSecurity权限系统UserDeatils&emsp;&emsp;SpringSecurity定义的用户接口，当我们需要自定义一些属性时，需要实现该接口。 GrantedAuthority&emsp;&emsp;SpringSecurity定义的用户权限接口，自定义权限需要实现该接口。 &emsp;&emsp;authority是权限字段，需要注意的是在config中配置的权限会被加上ROLE_前缀，比如我们的配置authorizeRequests().antMatchers(&quot;/test&quot;).hasRole(&quot;test&quot;)，配置了一个test权限但我们存储的权限字段（authority）应该是ROLE_test。 UserDetailsService&emsp;&emsp;Security中的用户Service，自定义用户服务类需要实现该接口,我们在loadUserByUsername中根据传入的用户名查询我们当前系统对应该对象的用户名和权限，构造UserDetails对象，再有框架去验证传入的对象信息和我们系统的对象信息是否一致。 SecurityContextHolder&emsp;&emsp;用户在完成登录后 Security 会将用户信息存储到这个类中，之后其他流程需要得到用户信息时都是从这个类中获得，用户信息被封装成 SecurityContext ，而实际存储的类是SecurityContextHolderStrategy，默认的SecurityContextHolderStrategy 实现类是 ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。&emsp;&emsp;手动填充 SecurityContextHolder 示例： &emsp;&emsp;对于使用 token 鉴权的系统，我们就可以验证token后手动填充SecurityContextHolder，填充时机只要在执行投票器之前即可，或者干脆可以在投票器中填充，然后在登出操作中清空SecurityContextHolder。 Security扩展&emsp;&emsp;可扩展的部分有: &emsp;&emsp;1.鉴权失败处理器&emsp;&emsp;Security 鉴权失败默认跳转登录页面，我们可以实现AccessDeniedHandler接口，重写 handle() 方法来自定义处理逻辑；然后参考配置类说明将处理器加入到配置当中。 &emsp;&emsp;2.验证器&emsp;&emsp;实现 AuthenticationProvider 接口来实现自己验证逻辑。需要注意的是在这个类里面就算你抛出异常，也不会中断验证流程，而是算你验证失败，我们由流程图知道，只要有一个验证器验证成功，就算验证成功，所以你需要留意这一点。 &emsp;&emsp;3.登录成功处理器&emsp;&emsp;在Security中验证成功默认跳转到上一次请求页面或者路径为 “/“ 的页面，我们同样可以自定义：继承SimpleUrlAuthenticationSuccessHandler这个类或者实现AuthenticationSuccessHandler接口。我这里建议采用继承的方式,SimpleUrlAuthenticationSuccessHandler是默认的处理器，采用继承可以契合里氏替换原则，提高代码的复用性和避免不必要的错误。 &emsp;&emsp;4.投票器&emsp;&emsp;投票器可继承WebExpressionVoter或者实现 AccessDecisionVoter接口；WebExpressionVoter是Security默认的投票器；我这里同样建议采用继承的方式；添加到配置的方式参考上文；&emsp;&emsp;注意：投票器 vote 方法返回一个int值；-1代表反对，0代表弃权，1代表赞成；投票管理器收集投票结果，如果最终结果大于等于0则放行该请求。 &emsp;&emsp;5.自定义token处理过滤器&emsp;&emsp;自定义 token 处理器继承自 OncePerRequestFilter 或者 GenericFilterBean 或者 Filter 都可以，在这个处理器里面需要完成的逻辑是：获取请求里的 token，验证 token 是否合法然后填充 SecurityContextHolder ，虽然说过滤器只要添加在投票器之前就可以，但我这里还是建议添加在 http.addFilterAfter(new MyFittler(), LogoutFilter.class); &emsp;&emsp;6.登出成功处理器&emsp;&emsp;实现LogoutSuccessHandler接口，添加到配置的方式参考上文。 &emsp;&emsp;7.登出失败处理器&emsp;&emsp;登录失败默认跳转到登录页，我们同样可以自定义。继承SimpleUrlAuthenticationFailureHandler 或者实现 AuthenticationFailureHandler。 &emsp;&emsp;8.自定义UsernamePasswordAuthenticationFilter&emsp;&emsp;我们自定义UsernamePasswordAuthenticationFilter可以极大提高我们Security的灵活性（比如添加验证验证码是否正确的功能）。我们直接继承UsernamePasswordAuthenticationFilter，然后在配置类中初始化这个过滤器，给这个过滤器添加登录失败处理器，登录成功处理器，登录管理器，登录请求url 。 &emsp;&emsp;示例代码 六、总结&emsp;&emsp;对于Security的扩展配置关键在于configure(HttpSecurityhttp)方法；扩展认证方式可以自定义authenticationManager并加入自己验证器，在验证器中抛出异常不会终止验证流程；扩展鉴权方式可以自定义accessDecisionManager然后添加自己的投票器并绑定到对应的url（url 匹配方式为 ant）上，投票器vote(Authenticationauthentication,FilterInvocationfi,Collection&lt;ConfigAttribute&gt;attributes) 方法返回值为三种：-1 0 1，分别表示反对弃权赞成。 &emsp;&emsp;对于token认证的校验方式，可以暴露一个获取的接口，或者重写UsernamePasswordAuthenticationFilter过滤器和扩展登录成功处理器来获取token，然后在LogoutFilter之后添加一个自定义过滤器，用于校验和填充SecurityContextHolder。 &emsp;&emsp;另外，Security的处理器大部分都是重定向的，我们的项目如果是前后端分离的话，我们希望无论什么情况都返回json,那么就需要重写各个处理器了。"}]