[{"title":"Hystrix容错保护原理及配置","date":"2021-04-06T06:50:04.000Z","url":"/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/","tags":[["SpringCloud","/tags/SpringCloud/"],["Hystrix","/tags/Hystrix/"]],"categories":[["SpringCloud","/categories/SpringCloud/"],["Hystrix","/categories/SpringCloud/Hystrix/"]],"content":"&emsp;&emsp;如下图的过程所示，灾难性雪崩形成原因就大致如此："},{"title":"索引失效","date":"2021-04-02T03:13:19.000Z","url":"/2021/04/02/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/","tags":[["Sql","/tags/Sql/"],["Index","/tags/Index/"]],"categories":[["Sql","/categories/Sql/"],["Index","/categories/Sql/Index/"]],"content":" 本文摘自： 番茄发烧了 &emsp;&emsp;虽然你这列上建了索引，查询条件也是索引列，但最终执行计划没有走它的索引。下面是引起这种问题的几个关键点。 列与列对比&emsp;&emsp;某个表中，有两列（id和c_id）都建了单独索引，下面这种查询条件不会走索引。 &emsp;&emsp;这种情况会被认为还不如走全表扫描。 存在NULL值条件&emsp;&emsp;我们在设计数据库表时，应该尽力避免NULL值出现，如果非要不可避免的要出现NULL值，也要给一个DEFAULT值，数值型可以给0、-1之类的， 字符串有时候给空串有问题，就给一个空格或其他。 &emsp;&emsp;如果索引列是可空的，很可能是不会给其建索引的，索引值是少于表的count(*)值的，所以这种情况下，执行计划自然就去扫描全表了。 NOT条件&emsp;&emsp;我们知道建立索引时，给每一个索引列建立一个条目，如果查询条件为等值或范围查询时，索引可以根据查询条件去找对应的条目。 &emsp;&emsp;反过来当查询条件为非时，索引定位就困难了，执行计划此时可能更倾向于全表扫描，这类的查询条件有：&lt;&gt;、NOT、in、not exists LIKE通配符&emsp;&emsp;当使用模糊搜索时，尽量采用后置的通配符，例如：name||’%’，因为走索引时，其会从前去匹配索引列，这时候是可以找到的，如果采用前匹配，那么查索引就会很麻烦，比如查询所有姓张的人，就可以去搜索’张%’。 &emsp;&emsp;相反如果你查询所有叫‘明’的人，那么只能是%明。这时候索引如何定位呢？前匹配的情况下，执行计划会更倾向于选择全表扫描。后匹配可以走INDEX RANGE SCAN。 &emsp;&emsp;所以业务设计的时候，尽量考虑到模糊搜索的问题，要更多的使用后置通配符。 条件上包括函数&emsp;&emsp;查询条件上尽量不要对索引列使用函数，比如下面这个SQL. &emsp;&emsp;这样是不会走索引的，因为索引在建立时会和计算后可能不同，无法定位到索引。但如果查询条件不是对索引列进行计算，那么依然可以走索引。比如 &emsp;&emsp;这样的函数还有：to_char、to_date、to_number、trunc等。 复合索引前导列区分大&emsp;&emsp;当复合索引前导列区分小的时候，我们有INDEX SKIP SCAN，当前导列区分度大，且查后导列的时候，前导列的分裂会非常耗资源，执行计划想，还不如全表扫描来的快，然后就索引失效了。 数据类型的转换&emsp;&emsp;当查询条件存在隐式转换时，索引会失效。 &emsp;&emsp;比如在数据库里id存的number类型，但是在查询时，却用了下面的形式： Connect By Level&emsp;&emsp;使用connect by level时，不会走索引。 谓词运算&emsp;&emsp;我们在上面说，不能对索引列进行函数运算，这也包括加减乘除的谓词运算，这也会使索引失效。 &emsp;&emsp;建立一个sunyang表，索引为id，看这个SQL： &emsp;&emsp;这里很明显对索引列id进行了’/2’除二运算，这时候就会索引失效，这种情况应该改写为： &emsp;&emsp;就可以使用索引了。 Vistual Index&emsp;&emsp;先说明一下，虚拟索引的建立是否有用，需要看具体的执行计划，如果起作用就可以建一个，如果不起作用就算了。普通索引这么建： &emsp;&emsp;虚拟索引Vistual Index这么建： &emsp;&emsp;做了一个实验，首先创建一个表： &emsp;&emsp;其中id为普通索引，a为虚拟索引。 &emsp;&emsp;在表中插入十万条数据 &emsp;&emsp;接着分别去执行下面的SQL看时间，由于在内网机做实验，图贴不出来，数据保证真实性。 &emsp;&emsp;因为在执行过一次后，oracle对结果集缓存了，所以第二次执行耗时不走索引，走内存就都一样了。 &emsp;&emsp;可以看到在这种情况下，虚拟索引比普通索引快了一倍。 &emsp;&emsp;具体虚拟索引的使用细节，这里不再展开讨论。 Invisible Index&emsp;&emsp;Invisible Index是oracle 11g提供的新功能，对优化器（还接到前面博客里讲到的CBO吗）不可见，MySQL 也有，MySQL 8.0 中的索引可以隐藏了。我感觉这个功能更主要的是测试用，假如一个表上有那么多索引，一个一个去看执行计划调试就很慢了，这时候不如建一个对表和查询都没有影响的Invisible Index来进行调试，就显得很好了。 &emsp;&emsp;通过下面的语句来操作索引 &emsp;&emsp;如果想让CBO看到Invisible Index，需要加入这句： "},{"title":"SpringCloud组件：Ribbon的负载均衡策略及原理","date":"2021-04-01T09:15:03.000Z","url":"/2021/04/01/Ribbon%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E5%8F%8A%E5%8E%9F%E7%90%86/","tags":[["SpringCloud","/tags/SpringCloud/"],["Ribbon","/tags/Ribbon/"]],"categories":[["SpringCloud","/categories/SpringCloud/"],["Ribbon","/categories/SpringCloud/Ribbon/"]],"content":" 本文章摘抄自网站博客，纯属兴趣摘抄自本博客 &emsp;&emsp;Load Balance负载均衡是用于解决一台机器(一个进程)无法解决所有请求而产生的一种算法。像nginx可以使用负载均衡分配流量，ribbon为客户端提供负载均衡，dubbo服务调用里的负载均衡等等，很多地方都使用到了负载均衡。&emsp;&emsp;使用负载均衡带来的好处很明显： 当集群里的1台或者多台服务器down的时候，剩余的没有down的服务器可以保证服务的继续使用 使用了更多的机器保证了机器的良性使用，不会由于某一高峰时刻导致系统cpu急剧上升&emsp;&emsp;负载均衡有好几种实现策略，常见的有： 随机 (Random) 轮询 (RoundRobin) 一致性哈希 (ConsistentHash) 哈希 (Hash) 加权（Weighted） ILoadBalance 负载均衡器 &emsp;&emsp;ribbon是一个为客户端提供负载均衡功能的服务，它内部提供了一个叫做ILoadBalance的接口代表负载均衡器的操作，比如有添加服务器操作、选择服务器操作、获取所有的服务器列表、获取可用的服务器列表等等。 &emsp;&emsp;ILoadBalance的继承关系如下： &emsp;&emsp;负载均衡器是从EurekaClient（EurekaClient的实现类为DiscoveryClient）获取服务信息，根据IRule去路由，并且根据IPing判断服务的可用性。 &emsp;&emsp;负载均衡器多久一次去获取一次从Eureka Client获取注册信息呢？在BaseLoadBalancer类下，BaseLoadBalancer的构造函数，该构造函数开启了一个PingTask任务setupPingTask();，代码如下： &emsp;&emsp;setupPingTask()的具体代码逻辑，它开启了ShutdownEnabledTimer执行PingTask任务，在默认情况下pingIntervalSeconds为10，即每10秒钟，向EurekaClient发送一次”ping”。 &emsp;&emsp;PingTask源码，即new一个Pinger对象，并执行runPinger()方法。 &emsp;&emsp;查看Pinger的runPinger()方法，最终根据 pingerStrategy.pingServers(ping, allServers)来获取服务的可用性，如果该返回结果，如之前相同，则不去向EurekaClient获取注册列表，如果不同则通知ServerStatusChangeListener或者changeListeners发生了改变，进行更新或者重新拉取。 完整过程是： &emsp;&emsp;LoadBalancerClient（RibbonLoadBalancerClient是实现类）在初始化的时候（execute方法），会通过ILoadBalance（BaseLoadBalancer是实现类）向Eureka注册中心获取服务注册列表，并且每10s一次向EurekaClient发送“ping”，来判断服务的可用性，如果服务的可用性发生了改变或者服务数量和之前的不一致，则从注册中心更新或者重新拉取。LoadBalancerClient有了这些服务注册列表，就可以根据具体的IRule来进行负载均衡。 IRule 路由 &emsp;&emsp;IRule接口代表负载均衡策略： &emsp;&emsp;IRule接口的实现类有以下几种： &emsp;&emsp;其中RandomRule表示随机策略、RoundRobinRule表示轮询策略、WeightedResponseTimeRule表示加权策略、BestAvailableRule表示请求数最少策略等等。 &emsp;&emsp;随机策略很简单，就是从服务器中随机选择一个服务器，RandomRule的实现代码如下： &emsp;&emsp;RoundRobinRule轮询策略表示每次都取下一个服务器，比如一共有5台服务器，第1次取第1台，第2次取第2台，第3次取第3台，以此类推： &emsp;&emsp;WeightedResponseTimeRule继承了RoundRobinRule，开始的时候还没有权重列表，采用父类的轮询方式，有一个默认每30秒更新一次权重列表的定时任务，该定时任务会根据实例的响应时间来更新权重列表，choose方法做的事情就是，用一个(0,1)的随机double数乘以最大的权重得到randomWeight，然后遍历权重列表，找出第一个比randomWeight大的实例下标，然后返回该实例，代码略。 &emsp;&emsp;BestAvailableRule策略用来选取最少并发量请求的服务器： &emsp;&emsp;使用Ribbon提供的负载均衡策略很简单，只需以下几部： 1、创建具有负载均衡功能的RestTemplate实例 &emsp;&emsp;使用RestTemplate进行rest操作的时候，会自动使用负载均衡策略，它内部会在RestTemplate中加入LoadBalancerInterceptor这个拦截器，这个拦截器的作用就是使用负载均衡。 &emsp;&emsp;默认情况下会采用轮询策略，如果希望采用其它策略，则指定IRule实现，如： &emsp;&emsp;这种方式对Feign也有效。 &emsp;&emsp;我们也可以参考ribbon，自己写一个负载均衡实现类。 &emsp;&emsp;可以通过下面方法获取负载均衡策略最终选择了哪个服务实例： "},{"title":"事务注解@Transactional失效的3种场景及解决办法","date":"2021-03-31T06:16:48.000Z","url":"/2021/03/31/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional%E5%A4%B1%E6%95%88%E7%9A%843%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","tags":[["Spring","/tags/Spring/"],["Annotation","/tags/Annotation/"]],"categories":[["Spring","/categories/Spring/"],["Annotation","/categories/Spring/Annotation/"],["Transactional","/categories/Spring/Annotation/Transactional/"]],"content":" 本问引用自博客： 一撸向北 一、Transactional失效场景介绍第一种&emsp;&emsp;Transactional注解标注方法修饰符为非public时，@Transactional注解将会不起作用，例如以下代码，定义一个错误的@Transactional标注实现，修饰一个默认访问符的方法 &emsp;&emsp;在同一个包内，新建调用对象，进行访问。 &emsp;&emsp;测试用例 &emsp;&emsp;以上的访问方式，导致事务没开启，因此在方法抛出异常时，testMapper.insert(new Test(10,20,30));操作不会进行回滚。如果TestServiceImpl#insertTestWrongModifier方法由default改为public的话将会正常开启事务，testMapper.insert(new Test(10,20,30));将会进行回滚。 第二种&emsp;&emsp;在类内部调用调用同一类内部@Transactional标注的方法。这种情况下也会导致事务不开启。示例代码如下，设置一个内部调用 &emsp;&emsp;测试用例 &emsp;&emsp;上面就是使用的测试代码，运行测试知道，外部调用事务方法能够征程开启事务，testMapper.insert(new Test(10,20,30))操作将会被回滚； &emsp;&emsp;然后运行另外一个测试用例，调用一个方法在类内部调用内部被@Transactional标注的事务方法，运行结果是事务不会正常开启，testMapper.insert(new Test(10,20,30))操作将会保存到数据库不会进行回滚。 第三种&emsp;emsp;事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。示例代码如下: &emsp;&emsp;测试代码如下： &emsp;&emsp;运行测试用例发现，虽然抛出异常，但是异常被捕捉了，没有抛出到方法 外， testMapper.insert(new Test(210,20,30))操作并没有回滚。 &emsp;&emsp;以上三种就是@Transactional注解不起作用，@Transactional注解失效的主要原因。下面结合spring中对于@Transactional的注解实现源码分析为何导致@Transactional注解不起作用。 二、**@Transactional注解不起作用原理分析**第一种&emsp;&emsp;@Transactional注解标注方法修饰符为非public时，@Transactional注解将会不起作用。这里分析 的原因是，@Transactional是基于动态代理实现的，@Transactional注解实现原理中分析了实现方法，在bean初始化过程中，对含有@Transactional标注的bean实例创建代理对象，这里就存在一个spring扫描@Transactional注解信息的过程，不幸的是源码中体现，标注@Transactional的方法如果修饰符不是public，那么就默认方法的@Transactional信息为空，那么将不会对bean进行代理对象创建或者不会对方法进行代理调用 &emsp;&emsp;@Transactional注解实现原理中，介绍了如何判定一个bean是否创建代理对象，大概逻辑是，根据spring创建好一个aop切点BeanFactoryTransactionAttributeSourceAdvisor实例，遍历当前bean的class的方法对象，判断方法上面的注解信息是否包含@Transactional，如果bean任何一个方法包含@Transactional注解信息，那么就是适配这个BeanFactoryTransactionAttributeSourceAdvisor切点。则需要创建代理对象，然后代理逻辑为我们管理事务开闭逻辑。 &emsp;&emsp;spring源码中，在拦截bean的创建过程，寻找bean适配的切点时，运用到下面的方法，目的就是寻找方法上面的@Transactional信息，如果有，就表示切点BeanFactoryTransactionAttributeSourceAdvisor能够应用（canApply）到bean中，AopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class&lt;?&gt;, boolean)。 &emsp;&emsp;我们可以在上面的方法打断点，一步一步调试跟踪代码，最终上面的代码还会调用如下方法来判断。在下面的方法上断点，回头看看方法调用堆栈也是不错的方式跟踪。推荐： &emsp;&emsp;AbstractFallbackTransactionAttributeSource#getTransactionAttribute &emsp;&emsp;AbstractFallbackTransactionAttributeSource#computeTransactionAttribute 不创建代理对象&emsp;&emsp;所以，如果所有方法上的修饰符都是非public的时候，那么将不会创建代理对象。以一开始的测试代码为例，如果正常的修饰符的testService是下面图片中的，经过cglib创建的代理对象。 &emsp;&emsp;如果class中的方法都是非public的那么将不是代理对象。 不进行代理调用&emsp;&emsp;考虑一种情况，如下面代码所示。两个方法都被@Transactional注解标注，但是一个有public修饰符一个没有，那么这种情况我们可以预见的话，一定会创建代理对象，因为至少有一个public修饰符的@Transactional注解标注方法。 &emsp;&emsp;创建了代理对象，insertTestWrongModifier就会开启事务吗？答案是不会。 &emsp;&emsp;原因是在动态代理对象进行代理逻辑调用时，在cglib创建的代理对象的拦截函数中CglibAopProxy.DynamicAdvisedInterceptor#intercept，有一个逻辑如下，目的是获取当前被代理对象的当前需要执行的method适配的aop逻辑。 &emsp;&emsp;而针对@Transactional注解查找aop逻辑过程，相似地，也是执行一次 &emsp;&emsp;AbstractFallbackTransactionAttributeSource#getTransactionAttribute&emsp;&emsp;AbstractFallbackTransactionAttributeSource#computeTransactionAttribute 也就是说还需要找一个方法上的@Transactional注解信息，没有的话就不执行代理@Transactional对应的代理逻辑，直接执行方法。没有了@Transactional注解代理逻辑，就无法开启事务，这也是上一篇已经讲到的。 第二种&emsp;&emsp;在类内部调用调用类内部@Transactional标注的方法。这种情况下也会导致事务不开启。 &emsp;&emsp;经过对第一种的详细分析，对这种情况为何不开启事务管理，原因应该也能猜到； &emsp;&emsp;既然事务管理是基于动态代理对象的代理逻辑实现的，那么如果在类内部调用类内部的事务方法，这个调用事务方法的过程并不是通过代理对象来调用的，而是直接通过this对象来调用方法，绕过的代理对象，肯定就是没有代理逻辑了。 &emsp;&emsp;其实我们可以这样玩，内部调用也能实现开启事务，代码如下。 &emsp;&emsp;上面就是使用了代理对象进行事务调用，所以能够开启事务管理，但是实际操作中，没人会闲的蛋疼这样子玩。 第三种&emsp;&emsp;事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。 &emsp;&emsp;这种的话，可能我们比较常见，问题就出在代理逻辑中，我们先看看源码里面动态代理逻辑是如何为我们管理事务的。 &emsp;&emsp;TransactionAspectSupport#invokeWithinTransaction &emsp;&emsp;代码如下: &emsp;&emsp;所以看了上面的代码就一目了然了，事务想要回滚，必须能够在这里捕捉到异常才行，如果异常中途被捕捉掉，那么事务将不会回滚。 &emsp;&emsp;总结了以上几种情况。"},{"title":"objective","date":"2021-03-29T03:39:46.000Z","url":"/2021/03/29/objective/","tags":[["target","/tags/target/"]],"categories":[["undefined",""]],"content":"1.短期目标：第一阶段1.1 输出Spring Security 原理文档（简单讲解，后续会陆续增加详细说明，在后续目标中再确定）1.2 输出Spring Security Demo学习文档（包含简单的源码讲解）1.3 输出Spring Security核心源码学习文档1.4 学习OAuth2.0框架1.5 输出OAuth2.0原理文档…… 每日目标 保证每日更新博客内容 "},{"title":"Spring Security Demo 学习","date":"2021-03-24T16:00:00.000Z","url":"/2021/03/25/SpringSecurityDemoStudy/","tags":[["demo","/tags/demo/"],["Spring Security","/tags/Spring-Security/"],["Spring Boot","/tags/Spring-Boot/"]],"categories":[["Spring Security","/categories/Spring-Security/"],["Study","/categories/Spring-Security/Study/"],["Demo","/categories/Spring-Security/Study/Demo/"]],"content":" 本问主要基于Spring boot框架进行Demo说明，首先创建一个Springboot 工程。 1.创建Springboot 工程2.引入Spring Security 依赖&emsp;&emsp;我们可以直接引入Spring Security 的starter包 &emsp;&emsp;当我们查看spring-boot-starter-security引入的依赖时，我们可以看到starter主要引入了Spring Security的spring-security-config和spring-security-web包，我们也可以手动引入这两个包 3.Demo学习3.1Spring Security默认配置&emsp;&emsp;我们建立的Spring boot工程默认端口号为8080，在引入Spring Security包之前，启动服务，访问;此时页面显示404，无法找到页面；此时我们在将Spring Security的依赖引入，重启服务，再次访问服务，此时我们可以看到如下页面： &emsp;&emsp;这是一个表单认证的登录页面，也就是说当引入Spring Security依赖后，服务就已经开启Spring Security的认证功能，那既然Spring Security既然引入依赖后就默认开启了认证功能，是不是就有默认的用户名和密码？其实Spring Security中有一个SecurityProperties配置类中的一个静态内部类中告诉了我们默认的用户名和密码，可以看到默认用户名和密码分别是user和uuid生成的一串随机码，此时我们只能明确一个用户名是user，密码的随机字符串我们却不知道。 &emsp;&emsp;此时我们查看这个内部类被谁调用过，是不是可以从调用处能够看到默认密码的信息，当我们查看调用方时，我们可以看到一个类名：UserDetailsServiceAutoConfiguration的类，如果认真看服务启动时打印的信息的话，可以看到控制台其实打印了这个类的信息： &emsp;&emsp;查看这个类的代码： &emsp;&emsp;在这个类的注释可以知道，这个自动配置类时记忆了一个默认的用户，在定义AuthenticationManager、AuthenticationProvider、UserDetailsService中任一类时，这个自动配置类会被禁用。&emsp;&emsp;我们可以看到在这个类的getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder)方法中通过日志的方式打印了密码的信息，那我们在看看之前截截图中打印的控制台信息，第二处标红就是上述类方法中打印的密码信息，此时我们已经知道了Spring Security在配置用户名和密码的情况下默认的用户密码为user和控制台打印出的随机码。&emsp;&emsp;此时我们再访问 ,输入默认的用户名和密码，此时点击Sign in按钮后，页面跳转依然显示404，其实Spring Security已经验证了信息，这个404是我们未定义访问的接口返回的信息或需要跳转的页面。&emsp;&emsp;我们可以定义一下访问接口的，在这之前我们先通过配置文件修改一下我们当前的用户名和密码，在配置文件中增加如下配置： &emsp;&emsp;重启服务，发现此前控制台打印的UserDetailsServiceAutoConfiguration信息和随机密码在控制台已经不打印了，此时我们在登录页输入我们配置的用户名和密码，发现效果和之前相同，但因为我们没有配置接口信息，无法确认验证是否进行及配置是否生效。&emsp;&emsp;我们在服务中建一个测试的Controller &emsp;&emsp;此时我们重启服务再去页面登录后查看效果，此时页面展示了我们接口中定义的Hello World的字符串，但此时是否说明我们Spring Security已经验证成功？还是说Spring Security没有做认证，只是提供了登录页面无论输入什么用户名和密码都会成功呢？？我们返回登录页面，输入一个错误的用户名或者密码来验证一下。&emsp;&emsp;当我们输入错误的用户名或者密码时，我们可以看到页面并未跳转且登录页面显示“用户名或密码错误”，此时可以说明Spring Security已经对我们的请求进行了简单的认证。&emsp;&emsp;但我们现在只是验证了引入了Spring Security的默认配置，但我们实际使用中需要做到Spring Security 的可配置，以适应我们项目的需求，Spring Security本身和Spring框架一样，提供了框架了可扩展性，所以后续过程中，我们就要实现的Spring Security的扩展性配置。 3.2 Spring Security 配置&emsp;&emsp;要使用Spring Security的认证和鉴权功能以满足我们的产品，我们就需要知道如何去配置Spring Security以满足我们的需求使用。&emsp;&emsp;根据Spring Security官网介绍，完成Spring Seccurity配置需要继承"},{"title":"SpringSecurity原理","date":"2021-03-02T09:07:54.000Z","url":"/2021/03/02/SpringSecurity%E5%8E%9F%E7%90%86/","tags":[["spring security","/tags/spring-security/"]],"categories":[["Spring Security","/categories/Spring-Security/"],["base","/categories/Spring-Security/base/"]],"content":"SpringSecurity原理一、SpringSecurity过滤器链 SpringSecurity的底层实现是一条过滤器链，也就是说用户进来后，由这些过滤器链判断是否有请求的权限，如果有权限则放过；没有权限的化就会抛出异常，重定向到要跳转的页面 SpringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤器链的各个进行说明:&emsp;&emsp;2.1 WebAsyncManagerIntegrationFilter：将Security上下文与Spring Web中用于处理异步请求映射的WebAsyncManager进行集成;&emsp;&emsp;2.2 SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个”仓储”中，然后将SecurityContextHolder中的信息清除，例如：在Session中维护一个用户的安全信息就是这个过滤器处理的;&emsp;&emsp;2.3HeaderWriterFilter：用于将头信息加入到响应中;&emsp;&emsp;2.4 CsrfFilter：用于处理跨站请求伪造;&emsp;&emsp;2.5 LogoutFilter：用于处理退出登录;&emsp;&emsp;2.6 UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自/login的请求。从表单中获取用户名和密码时，默认使用的name的值为username和password，这两个值可以通过设置这个过滤器的usernameParameter和passwordParameter两个参数的值进行修改。&emsp;&emsp;2.7 DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且在需要进行登陆时生成一个登录表单页面。&emsp;&emsp;2.8 BasicAuthenticationFilter：检测和处理http basic认证。&emsp;&emsp;2.9 RequestCacheAwareFilter：用来处理请求的缓存。&emsp;&emsp;2.10 SecurityContextHolderAwareRequestFilter：主要包装请求的Requeest。&emsp;&emsp;2.11 AnonymousAuthenticationFilter： 检测SecurityContextHolder中是否存在Authentication对象，如果不存在为其提供一个匿名Authentication。&emsp;&emsp;2.12 SessionManagementFilter：管理session的过滤器。&emsp;&emsp;2.13 ExceptionTranslationFilter：处理AccessDeniedException和AuthenticationException异常。&emsp;&emsp;2.14 FilterSecurityInterceptor：过滤器链的出口。&emsp;&emsp;2.15 RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时，从cookie中找出用户的信息，如果Spring Security能够识别出用户提供的remember me cookie,用户将不必填写用户名和密码，而是直接登录进入系统，该过滤器默认不开启。二、SpringSecurity流程图(如链接中流程图)&emsp;&emsp;SpringSecurity流程图 三、SpringSecurity流程说明 客户端发起请求，进入过滤器链 当到LogoutFilter的时候判断是否是登出路径，如果是登出路径则到LogoutHandler，如果登出成功则到logoutSuccessHandler登出成功处理，如果登出失败则由ExceptionTranslationFilter，如果不是登出路径则直接进入下一个过滤器。 当到UsernamePasswordAuthenticationFilter的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到AuthenticationFailureHandler登录失败处理器处理，如果登录成功则到AuthenticationSuccessHandler登录成功处理器处理，如果不是登录请求则不进入该过滤器。 当到FilterSecurityInterceptor的时候会拿到uri，根据uri去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到Controller层否则到AccessDeniedHandler鉴权失败处理器处理。四、SpringSecurity配置(简单介绍，详细使用方案会在后续使用文档中说明，本文档主要是介绍文档)&emsp;&emsp;Springboot需要在WebSecurityconfigurerAdapter这个类中实现上述流程图的配置，代码中需要实现这个类并重写其中需要使用的方法配置伪代码 配置简介&emsp;&emsp;config(AuthenticationManagerBuilder auth) 配置Security认证的方法，AuthenticationManagerBuilder见明知义，就是构建一个Authentication的管理器，该类的功能参考SpringSecurity流程图中AuthenticationManager部分所示，该部分可以配置UserDetailsService和PasswordEncoder。UserDetailsService用于在认证器中根据用户传过来的用户名查找一个用户，在使用过程中，可以实现该接口，重写其中的方法，加载一个UserDeatils信息，认证通过后就会将该对象赋给认证通过的Authentication的Principal对象，后续需要对象信息时就通过SecurityContextHolder获取存放在SecurityContext中的Authentication的principal。PasswordEncoder用于密码的加密与比对，可以自定义加密方法。&emsp;&emsp;configure(WebSecurity web) 配置静态资源的权限。&emsp;&emsp;config(HttpSecurity http) 这个配置方法是WebSecurityConfigurerAdapter的核心配置方法，每个配置我们可以分开说明。 &emsp;&emsp;此段代码配置了登录页请求路径，密码属性名，用户名属性名，和登录请求路径,permitAll()代表任意用户可访问。 ​ 此段代码是对权限的配置，这段代码表示访问/test的URL时需要有test的权限方可访问，anyRequest() 表示任意请求，authenticated()表示需要通过认证，accessDecisionManager() 表示绑定在url上的鉴权管理器。 &emsp;&emsp;用户登出时的相关配置，new MyLogoutSuccessHandler()登出成功后的处理，可自定义。 &emsp;&emsp;此段代码是关闭csrf。 &emsp;&emsp;此段代码是配置鉴权失败的处理器。 &emsp;&emsp;代码展示如何在过滤器链中插入自己的过滤器，addFilterBefore加在对应的过滤器之前，addFilterAfter加在对应的过滤器之后，addFilterAt加在过滤器同一位置，事实上框架原有的Filter在启动HttpSecurity配置的过程中，都由框架完成了其一定程度上固定的配置，是不允许更改替换的。根据测试结果来看，调用addFilterAt方法插入的Filter，会在这个位置上的原有Filter之前执行。 五、SpringSecurity权限系统UserDeatils&emsp;&emsp;SpringSecurity定义的用户接口，当我们需要自定义一些属性时，需要实现该接口。 GrantedAuthority&emsp;&emsp;SpringSecurity定义的用户权限接口，自定义权限需要实现该接口。 &emsp;&emsp;authority是权限字段，需要注意的是在config中配置的权限会被加上ROLE_前缀，比如我们的配置authorizeRequests().antMatchers(&quot;/test&quot;).hasRole(&quot;test&quot;)，配置了一个test权限但我们存储的权限字段（authority）应该是ROLE_test。 UserDetailsService&emsp;&emsp;Security中的用户Service，自定义用户服务类需要实现该接口,我们在loadUserByUsername中根据传入的用户名查询我们当前系统对应该对象的用户名和权限，构造UserDetails对象，再有框架去验证传入的对象信息和我们系统的对象信息是否一致。 SecurityContextHolder&emsp;&emsp;用户在完成登录后 Security 会将用户信息存储到这个类中，之后其他流程需要得到用户信息时都是从这个类中获得，用户信息被封装成 SecurityContext ，而实际存储的类是SecurityContextHolderStrategy，默认的SecurityContextHolderStrategy 实现类是 ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。&emsp;&emsp;手动填充 SecurityContextHolder 示例： &emsp;&emsp;对于使用 token 鉴权的系统，我们就可以验证token后手动填充SecurityContextHolder，填充时机只要在执行投票器之前即可，或者干脆可以在投票器中填充，然后在登出操作中清空SecurityContextHolder。 Security扩展&emsp;&emsp;可扩展的部分有: &emsp;&emsp;1.鉴权失败处理器&emsp;&emsp;Security 鉴权失败默认跳转登录页面，我们可以实现AccessDeniedHandler接口，重写 handle() 方法来自定义处理逻辑；然后参考配置类说明将处理器加入到配置当中。 &emsp;&emsp;2.验证器&emsp;&emsp;实现 AuthenticationProvider 接口来实现自己验证逻辑。需要注意的是在这个类里面就算你抛出异常，也不会中断验证流程，而是算你验证失败，我们由流程图知道，只要有一个验证器验证成功，就算验证成功，所以你需要留意这一点。 &emsp;&emsp;3.登录成功处理器&emsp;&emsp;在Security中验证成功默认跳转到上一次请求页面或者路径为 “/“ 的页面，我们同样可以自定义：继承SimpleUrlAuthenticationSuccessHandler这个类或者实现AuthenticationSuccessHandler接口。我这里建议采用继承的方式,SimpleUrlAuthenticationSuccessHandler是默认的处理器，采用继承可以契合里氏替换原则，提高代码的复用性和避免不必要的错误。 &emsp;&emsp;4.投票器&emsp;&emsp;投票器可继承WebExpressionVoter或者实现 AccessDecisionVoter接口；WebExpressionVoter是Security默认的投票器；我这里同样建议采用继承的方式；添加到配置的方式参考上文；&emsp;&emsp;注意：投票器 vote 方法返回一个int值；-1代表反对，0代表弃权，1代表赞成；投票管理器收集投票结果，如果最终结果大于等于0则放行该请求。 &emsp;&emsp;5.自定义token处理过滤器&emsp;&emsp;自定义 token 处理器继承自 OncePerRequestFilter 或者 GenericFilterBean 或者 Filter 都可以，在这个处理器里面需要完成的逻辑是：获取请求里的 token，验证 token 是否合法然后填充 SecurityContextHolder ，虽然说过滤器只要添加在投票器之前就可以，但我这里还是建议添加在 http.addFilterAfter(new MyFittler(), LogoutFilter.class); &emsp;&emsp;6.登出成功处理器&emsp;&emsp;实现LogoutSuccessHandler接口，添加到配置的方式参考上文。 &emsp;&emsp;7.登出失败处理器&emsp;&emsp;登录失败默认跳转到登录页，我们同样可以自定义。继承SimpleUrlAuthenticationFailureHandler 或者实现 AuthenticationFailureHandler。 &emsp;&emsp;8.自定义UsernamePasswordAuthenticationFilter&emsp;&emsp;我们自定义UsernamePasswordAuthenticationFilter可以极大提高我们Security的灵活性（比如添加验证验证码是否正确的功能）。我们直接继承UsernamePasswordAuthenticationFilter，然后在配置类中初始化这个过滤器，给这个过滤器添加登录失败处理器，登录成功处理器，登录管理器，登录请求url 。 &emsp;&emsp;示例代码 六、总结&emsp;&emsp;对于Security的扩展配置关键在于configure(HttpSecurityhttp)方法；扩展认证方式可以自定义authenticationManager并加入自己验证器，在验证器中抛出异常不会终止验证流程；扩展鉴权方式可以自定义accessDecisionManager然后添加自己的投票器并绑定到对应的url（url 匹配方式为 ant）上，投票器vote(Authenticationauthentication,FilterInvocationfi,Collection&lt;ConfigAttribute&gt;attributes) 方法返回值为三种：-1 0 1，分别表示反对弃权赞成。 &emsp;&emsp;对于token认证的校验方式，可以暴露一个获取的接口，或者重写UsernamePasswordAuthenticationFilter过滤器和扩展登录成功处理器来获取token，然后在LogoutFilter之后添加一个自定义过滤器，用于校验和填充SecurityContextHolder。 &emsp;&emsp;另外，Security的处理器大部分都是重定向的，我们的项目如果是前后端分离的话，我们希望无论什么情况都返回json,那么就需要重写各个处理器了。"}]