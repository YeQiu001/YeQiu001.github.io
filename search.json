[{"title":"SpringBoot定时任务和异步线程池","date":"2021-04-19T06:04:45.000Z","url":"/2021/04/19/SpringBoot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/","tags":[["Springboot","/tags/Springboot/"],["ScheduledTask","/tags/ScheduledTask/"]],"categories":[["Springboot","/categories/Springboot/"]],"content":" 博客地址: 溪~源 项目中最近使用了多个定时任务处理业务需求，于是在实现业务逻辑过程中，产生了上图一些思考和疑问，现在利用空余时间进行一次复盘。 项目搭建项目搭建环境：JDK1.8+SpringBoot 主启动类：加上@EnableScheduling 新建定时任务配置类：ScheduledTask；定义两个定时任务，简单打印一下线程名字和时间戳 源码如下： 一、多任务串行执行1.相同定时任务先解决多任务定时相同时间，是否存在优先级执行顺序，执行上面的代码，打印日志如下图： 从控制台日志发现，两个定时任务并没有存在一定的执行顺序，存在乱序现象。 故：串行定时任务，没有明显的优先级关系。 2.一个定时任务阻塞​ 为了实现此场景的条件，将定时任务1中添加死循环逻辑。源码改动如下： 从控制台可以得出：多个定时任务时串行执行的,如果一个任务出现阻塞，其他的任务都会受到影响。 二、多任务并行执行如果要实现并行执行，启动类需要在上面的基础上新增注解@EnableAsync。任务方法上新增@Async注解。 源码如下： 执行结果如下图： 从控制台中打印的线程名发现：每次执行任务时，都是创建新的线程执行，使用默认线程池SimpleAsyncTaskExecutor。 默认情况下异步调用使用的线程池是SimpleAsyncTaskExecutor，该线程池是不被推荐，因为该线程池的线程不重用，每次调用都会创建一个新的线程。所以需要我们自定义线程池。 自定义线程池1.自定义局部线程池局部线程池实际上就是指异步方法上需要指定使用该线程池，否则将使用默认线程池。 配置异步线程池源码如下： 定时任务源码修改如下： 控制台执行结果如下： 从图中依据线程名字，看到任务1均有自定义线程池defineAsyncTask-*执行，同时验证默认线程池SimpleAsyncTaskExecutor一直创建新线程执行。 2.定义全局线程池上面需在@Async()注解中指定使用自定义线程池才有效，如果我们即不想指定线程池，又不想使用默认线程池池—全局线程池。 定义全局线程池可以通过实现 AsyncConfigurer 或者继承 AsyncConfigurerSupport。 源码如下： 再次执行上面的任务，结果如下： 任务1，指定自定义线程池，则有该线程池执行任务，其余未指定线程池，则使用自定义的全局线程池执行任务。 异常处理使用过线程池执行任务的伙伴应该会知道，线程提交任务分为execute()方式和submit()方式。 对于异步submit提交任务时，使用Future.get()方法获取返回结果时，主线程阻塞并可以处理线程池中的异常。 对于execute()方式提交任务，当异步任务返回类型为 void，异常不会传播到调用线程，故需要通过实现 AsyncUncaughtExceptionHandler接口创建自定义异常处理。 故在上面配置全局线程池的基础上，处理异常。从源码中可以得出AsyncConfigurerSupport提供了两个方法，其中getAsyncExecutor()是定义线程池的，getAsyncUncaughtExceptionHandler()是用于处理异常的。 处理异常源码实现如下： 自定义异常处理实现类： 定义全局线程池重写getAsyncUncaughtExceptionHandler "},{"title":"Git subtree实现总项目与子项目间双向同步","date":"2021-04-15T05:59:37.000Z","url":"/2021/04/15/subtree%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/","tags":[["git","/tags/git/"],["subtree","/tags/subtree/"]],"categories":[["git","/categories/git/"]],"content":"一、"},{"title":"Gson转换int变为Double问题解决","date":"2021-04-09T07:39:33.000Z","url":"/2021/04/09/Gson%E8%BD%AC%E6%8D%A2int%E5%8F%98%E4%B8%BADouble%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","tags":[["JAVA","/tags/JAVA/"],["Gson","/tags/Gson/"]],"categories":[["JAVA","/categories/JAVA/"]],"content":"一、原因现状目前网络上的资料中有两种解决这个问题的办法。 第一种：修改源码。 第二种：添加指定类型的自定义解密工具。 所有能找到的资料中，都对第一种进行了忽略，认为修改源码改动太大，转而使用了第二种方式。 不论是注册Map的解析器，还是使用自定义的Bean对象，本质都是指定类型解析，也就是第二种，完全无法解决以下问题。 在这段代码中，你可以测试网络中找到的其他解决方式，你会发现所有设置都失效了。 原因是，当你使用 Class 对象作为解析类型时，Gson 会转入你自定义的解析器，而使用 TypeToken 时，Gson 无法将传入的参数与绑定的 TypeToken 对应，最终使用默认解析器。 根因分析接下来我们简述下反序列化的过程，Gson根据待解析的类型定位到具体的TypeAdaptor类，其接口的主要方法如下: 通过read方法从JsonReader中读取相应的数据组装成最终的对象，由于Data类中的extend字段的声明类型是Object，最终Gson会定位到内置的ObjectTypeAdaptor类，我们来分析一下该类的逻辑过程。 看到该逻辑过程我们看到，如果Json对应的是Object类型，最终会解析为Map&lt;String, Object&gt;类型；其中Object类型跟Json中具体的值有关，比如双引号的””值翻译为STRING。我们可以看下数值类型（NUMBER）全部转换为了Double类型，所以就有了我们之前的问题，整型数据被翻译为了Double类型，比如30变为了30.0。看到这，大家是不是也在想应该细分下NUMBER数值类型，按照整型和浮点型分开处理，我们看下JsonToken是否有更细分的类型。 我们发现这个枚举类的number类型定义比较宽泛，没有对数字类型进行细分，此时再看JsonReader.peek 可以看到其实在JsonReader的读取过程中是有细分整型和浮点型，可以对外转换后不再区分数值类型了，一种改法是直接修改源码，在JsonToken多定义定义一个整型Long，然后在读取的过程中细分下类型，修改ObjectTypeAdaptor的方法后大概如下所示 也就是如果我们需要重写TypeAdapter的read()方法 首先我们先创建一个类去继承TypeAdapter，然后重写Read方法，代码如下： ObjectTypeAdapter 在创建的 Gson 对象中是不存在的，其使用了内部的工厂对象（FACTORY）动态创建. 而 FACTORY 会在 Gson 的构造函数中加入 factories 对象中。 最终，factories 对象通过 Collections 的方法变为不可变列表后保存为成功变量。 找来找去，发现，我们只需要把 Gson 实例中的 factories 对象内部的工厂对象取代即可。 其实改动部分只有对 NUMBER 分支的细化，将原始数据是否包含小数点来作为其是否为整数与小数的依据。 我认为原始数据中字面值为 1.0 的数是小数，而字面值为 1 的数为整数。你也可以有自己的实现方式。 使用自定义工厂方法取代 Gson 实例中的工厂方法。 代码中，首先获得 gson 实例的 factories 属性，将属性设置为 public 访问权限，然后获得其属性 o。 因为在 gson 的创建过程中，factories 通过 Collections 的方法变为了不可修改对象，所以我们需要将其真实属性获得才能进行修改。 通过 Collections 的字节码对象获得其声明的所有内部类，遍历内部类获得 UnmodifiableList 类的字节码对象，最后获得其进行包装之前的真实列表数据 listField，并设置其访问权限为 public。 最终获得了真实的 factories 列表 list。 最后一步，得到 ObjectTypeAdapter.FACTORY 在列表中的位置，并用自定义的工厂对象取代之。需要注意的是，必须要将工厂对象同位置替换，因为解析优先级是和列表中的位置有关的。"},{"title":"SpringCloud组件：Hystrix容错保护原理及配置","date":"2021-04-06T06:50:04.000Z","url":"/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/","tags":[["SpringCloud","/tags/SpringCloud/"],["Hystrix","/tags/Hystrix/"]],"categories":[["SpringCloud","/categories/SpringCloud/"]],"content":" 本文摘自：kosamino 1.什么是灾难性雪崩效应？ &emsp;&emsp;如下图的过程所示，灾难性雪崩形成原因就大致如此： &emsp;&emsp;造成灾难性雪崩效应的原因，可以简单归结为下述三种： 服务提供者不可用。如：硬件故障、程序BUG、缓存击穿、并发请求量过大等。 重试加大流量。如：用户重试、代码重试逻辑等。 服务调用者不可用。如：同步请求阻塞造成的资源耗尽等。 &emsp;&emsp;雪崩效应最终的结果就是：服务链条中的某一个服务不可用，导致一系列的服务不可用，最终造成服务逻辑崩溃。这种问题造成的后果，往往是无法预料的。 2 如何解决灾难性雪崩效应？ &emsp;&emsp;解决灾难性雪崩效应的方式通常有：降级、隔离、熔断、请求缓存、请求合并。 &emsp;&emsp;在Spring cloud中处理服务雪崩效应，都需要依赖hystrix组件。在pom文件中都需要引入下述依赖： &emsp;&emsp;通常来说，开发的时候，使用ribbon处理服务灾难雪崩效应（因此章节2示例均采用Ribbon，章节3是Feign实现方式详解），开发的成本低。维护成本高。使用feign技术处理服务灾难雪崩效应，开发的成本较高，维护成本低。 2.1 降级&emsp;&emsp;降级是指，当请求超时、资源不足等情况发生时进行服务降级处理，不调用真实服务逻辑，而是使用快速失败（fallback）方式直接返回一个托底数据，保证服务链条的完整，避免服务雪崩。 &emsp;&emsp;解决服务雪崩效应，都是避免application client请求application service时，出现服务调用错误或网络问题。处理手法都是在application client中实现。我们需要在application client相关工程中导入hystrix依赖信息。 &emsp;&emsp;并在对应的启动类上增加新的注解@EnableCircuitBreaker，这个注解是用于开启hystrix熔断器的，简言之，就是让代码中的hystrix相关注解生效。 &emsp;&emsp;启动器代码： &emsp;&emsp;在调用application service相关代码中，增加新的方法注解@HystrixCommand，代表当前方法启用Hystrix处理服务雪崩效应。 &emsp;&emsp;@HystrixCommand注解中的属性：fallbackMethod - 代表当调用的application service出现问题时，调用哪个fallback快速失败处理方法返回托底数据。 &emsp;&emsp;实现类代码： 2.2 缓存&emsp;&emsp;缓存是指请求缓存。通常意义上说，就是将同样的GET请求结果缓存起来，使用缓存机制（如redis、mongodb）提升请求响应效率。 &emsp;&emsp;使用请求缓存时，需要注意非幂等性操作对缓存数据的影响。 &emsp;&emsp;请求缓存是依托某一缓存服务来实现的。在案例中使用redis作为缓存服务器，那么可以使用spring-data-redis来实现redis的访问操作。需要在application client相关工程中导入下述依赖： &emsp;&emsp;在Spring Cloud应用中，启用spring对cache的支持，需要在启动类中增加注解@EnableCaching，此注解代表当前应用开启spring对cache的支持。简言之就是使spring-data-redis相关的注解生效，如：@CacheConfig、@Cacheable、@CacheEvict等。 &emsp;&emsp;启动器： &emsp;&emsp;spring cloud会检查每个幂等性请求，如果请求完全相同（路径、参数等完全一致），则首先访问缓存redis，查看缓存数据，如果缓存中有数据，则不调用远程服务application service。如果缓存中没有数据，则调用远程服务，并将结果缓存到redis中，供后续请求使用。 &emsp;&emsp;如果请求是一个非幂等性操作，则会根据方法的注解来动态管理redis中的缓存数据，避免数据不一致。 注意：使用请求缓存会导致很多的隐患，如：缓存管理不当导致的数据不同步、问题排查困难等。在商业项目中，解决服务雪崩效应不推荐使用请求缓存。 &emsp;&emsp;实现类： 2.3 请求合并&emsp;&emsp;请求合并是指，在一定时间内，收集一定量的同类型请求，合并请求需求后，一次性访问服务提供者，得到批量结果。这种方式可以减少服务消费者和服务提供者之间的通讯次数，提升应用执行效率。 &emsp;&emsp;未使用请求合并： &emsp;&emsp;使用请求合并： 什么情况下使用请求合并： &emsp;&emsp;在微服务架构中，我们将一个项目拆分成很多个独立的模块，这些独立的模块通过远程调用来互相配合工作，但是，在高并发情况下，通信次数的增加会导致总的通信时间增加，同时，线程池的资源也是有限的，高并发环境会导致有大量的线程处于等待状态，进而导致响应延迟，为了解决这些问题，我们需要来了解Hystrix的请求合并。 通常来说，服务链条超出4个，不推荐使用请求合并。因为请求合并有等待时间。 请求合并的缺点： &emsp;&emsp;设置请求合并之后，本来一个请求可能5ms就搞定了，但是现在必须再等10ms看看还有没有其他的请求一起的，这样一个请求的耗时就从5ms增加到15ms了，不过，如果我们要发起的命令本身就是一个高延迟的命令，那么这个时候就可以使用请求合并了，因为这个时候时间窗的时间消耗就显得微不足道了，另外高并发也是请求合并的一个非常重要的场景。 &emsp;&emsp;引入依赖： &emsp;&emsp;启动器 &emsp;&emsp;使用注解@HystrixCollapser来描述需要合并请求的方法，并提供合并方法使用注解@HystrixCommand来描述。当合并条件（@HystrixCollapser）满足时，会触发合并方法（@HystrixCommand）来调用远程服务并得到结果。 &emsp;&emsp;@HystrixCollapser注解介绍：此注解描述的方法，返回值类型必须是java.util.concurrent.Future类型的。代表方法为异步方法。 @HystrixCollapser注解的属性： batchMethod - 请求合并方法名。 scope - 请求合并方式。可选值有REQUEST和GLOBAL。REQUEST代表在一个request请求生命周期内的多次远程服务调用请求需要合并处理，此为默认值。GLOBAL代表所有request线程内的多次远程服务调用请求需要合并处理。 timerDelayInMilliseconds - 多少时间间隔内的请求进行合并处理，默认值为10ms。建议设置时间间隔短一些，如果单位时间并发量不大，并没有请求合并的必要。 maxRequestsInBatch - 设置合并请求的最大极值，也就是timerDelayInMilliseconds时间内，最多合并多少个请求。默认值是Integer.MAX_VALUE。 &emsp;&emsp;实现类： 2.4 熔断&emsp;&emsp;当一定时间内，异常请求比例（请求超时、网络故障、服务异常等）达到阀值时，启动熔断器，熔断器一旦启动，则会停止调用具体服务逻辑，通过fallback快速返回托底数据，保证服务链的完整。 &emsp;&emsp;熔断有自动恢复机制，如：当熔断器启动后，每隔5秒，尝试将新的请求发送给服务提供者，如果服务可正常执行并返回结果，则关闭熔断器，服务恢复。如果仍旧调用失败，则继续返回托底数据，熔断器持续开启状态。 &emsp;&emsp;引入依赖： &emsp;&emsp;启动器： &emsp;&emsp;熔断的实现是在调用远程服务的方法上增加@HystrixCommand注解。当注解配置满足则开启或关闭熔断器。 &emsp;&emsp;注解属性描述： 2.5 隔离&emsp;&emsp;所谓隔离，就是当服务发生问题时，使用技术手段隔离请求，保证服务调用链的完整。隔离分为线程池隔离和信号量隔离两种实现方式。 2.5.1 线程池隔离&emsp;&emsp;所谓线程池隔离，就是将并发请求量大的部分服务使用独立的线程池处理，避免因个别服务并发过高导致整体应用宕机。 线程池隔离优点： 使用线程池隔离可以完全隔离依赖的服务，请求线程可以快速放回。 当线程池出现问题时，线程池是完全隔离状态的，是独立的，不会影响到其他服务的正常执行。 当崩溃的服务恢复时，线程池可以快速清理并恢复，不需要相对漫长的恢复等待。 独立的线程池也提供了并发处理能力。 线程池隔离缺点： &emsp;&emsp;线程池隔离机制，会导致服务硬件计算开销加大（CPU计算、调度等），每个命令的执行都涉及到排队、调度、上下文切换等，这些命令都是在一个单独的线程上运行的。 &emsp;&emsp;线程池隔离的实现方式同样是使用@HystrixCommand注解。相关注解配置属性如下： groupKey - 分组命名，在application client中会为每个application service服务设置一个分组，同一个分组下的服务调用使用同一个线程池。默认值为this.getClass().getSimpleName(); commandKey - Hystrix中的命令命名，默认为当前方法的方法名。可省略。用于标记当前要触发的远程服务是什么。 threadPoolKey - 线程池命名。要求一个应用中全局唯一。多个方法使用同一个线程池命名，代表使用同一个线程池。默认值是groupKey数据。 threadPoolProperties - 用于为线程池设置的参数。其类型为HystrixProperty数组。常用线程池设置参数有： coreSize - 线程池最大并发数，建议设置标准为：requests per second at peak when healthy * 99th percentile latency in second + some breathing room。即每秒最大支持请求数*（99%平均响应时间 + 一定量的缓冲时间(99%平均响应时间的10%-20%)）。如：每秒可以处理请求数为1000，99%的响应时间为60ms，自定义提供缓冲时间为60*0.2=12ms，那么结果是 1000*(0.060+0.012) = 72。 maxQueueSize - BlockingQueue的最大长度，默认值为-1，即不限制。如果设置为正数，等待队列将从同步队列SynchronousQueue转换为阻塞队列LinkedBlockingQueue。 queueSizeRejectionThreshold - 设置拒绝请求的临界值。默认值为5。此属性是配合阻塞队列使用的，也就是不适用maxQueueSize=-1（为-1的时候此值无效）的情况。是用于设置阻塞队列限制的，如果超出限制，则拒绝请求。此参数的意义就是在服务启动后，可以通过Hystrix的API调用config API动态修改，而不用用重启服务，不常用。 keepAliveTimeMinutes - 线程存活时间，单位是分钟。默认值为1。 execution.isolation.thread.timeoutInMilliseconds - 超时时间，默认为1000ms。当请求超时自动中断，返回fallback，避免服务长期阻塞。 execution.isolation.thread.interruptOnTimeout - 是否开启超时中断。默认为TRUE。和上一个属性配合使用。 &emsp;&emsp;引入依赖： &emsp;&emsp;启动器: &emsp;&emsp;实现类: &emsp;&emsp;关于线程池： 对于所有请求，都交由tomcat容器的线程池处理，是一个以http-nio开头的的线程池； 开启了线程池隔离后，tomcat容器默认的线程池会将请求转交给threadPoolKey定义名称的线程池，处理结束后，由定义的线程池进行返回，无需还回tomcat容器默认的线程池。线程池默认为当前方法名； 所有的fallback都单独由Hystrix创建的一个线程池处理。 2.5.2 信号量隔离&emsp;&emsp;所谓信号量隔离，就是设置一个并发处理的最大极值。当并发请求数超过极值时，通过fallback返回托底数据，保证服务完整性。 &emsp;&emsp;信号量隔离同样通过@HystrixCommand注解配置，常用注解属性有： commandProperty - 配置信号量隔离具体数据。属性类型为HystrixProperty数组，常用配置内容如下： execution.isolation.strategy - 设置隔离方式，默认为线程池隔离。可选值只有THREAD和SEMAPHORE。 execution.isolation.semaphore.maxConcurrentRequests - 最大信号量并发数，默认为10。 &emsp;&emsp;依赖注入和启动器同线程池隔离，实现类如下： 2.5.3线程池隔离和信号量隔离的对比对比 线程池隔离 信号量隔离 线程 请求处理线程和调用服务线程不是同一个线程 请求处理线程和调用服务线程是同一个线程 开销 资源开销大（需要处理线程排队、调度、上下文切换等） 无线程切换，开销小 异步 支持异步处理 不支持异步处理 并发支持 支持，由线程池容量限制并发能力 支持，由信号量配置限制并发能力 传递请求header 切换了线程，不能传递请求header 不切换线程，可以传递header 超时支持 支持超时处理，当请求超时，自动中断 不支持超时处理，必须等待远程调用结束，再判断是否超时 2.5.4线程池隔离和信号量隔离的选择 线程池隔离：请求并发大，耗时较长（一般都是计算大，服务链长或访问数据库）时使用线程池隔离。可以尽可能保证外部容器（如Tomcat）线程池可用，不会因为服务调用的原因导致请求阻塞等待。 信号量隔离：请求并发大，耗时短（计算小，服务链段或访问缓存）时使用信号量隔离。因为这类服务的响应快，不会占用外部容器（如Tomcat）线程池太长时间，减少线程的切换，可以避免不必要的开销，提高服务处理效率。 3 Feign的雪崩处理 &emsp;&emsp;在声明式远程服务调用Feign中，实现服务灾难性雪崩效应处理也是通过Hystrix实现的。而feign启动器spring-cloud-starter-feign中是包含Hystrix相关依赖的。 &emsp;&emsp;如果只使用服务降级、熔断功能不需要做独立依赖。如果需要使用Hystrix其他服务容错能力，需要依赖spring-cloud-starter-hystrix资源。 &emsp;&emsp;从Dalston版本后，feign默认关闭Hystrix支持。所以必须在全局配置文件中开启feign技术中的Hystrix支持。配置如下： &emsp;&emsp;如果不使用Hystrix服务容错功能，在application client端，服务接口只需要继承服务标准api接口即可实现远程服务调用。如果使用了Hystrix，则有不同的编写方式。具体如下。 3.1 代码实现 - 接口实现类方式&emsp;&emsp;定义和服务标准api相同的application client服务接口。并通过@FeignClient注解来描述fallback方法所在类是什么。这个fallback方法所在类就是接口的实现类，实现的方法就是接口中定义方法的fallback方法。 &emsp;&emsp;为接口提供实现类，类中的方法实现就是fallback逻辑。实现类需要spring容器管理，使用@Component注解来描述类型。 3.2 相关配置&emsp;&emsp;在Feign技术中，一般不使用请求合并，请求缓存等容错机制。常用的机制是隔离，降级和熔断。 3.2.1 Properties全局配置 3.2.2 YML全局配置&emsp;&emsp;YML配置文件，对SpringEL的支持更加优秀。可以通过SpringEL定制化的为每个服务调用配置Hystrix的容错处理方案。对Hystrix的配置粒度相比较Properties的配置方案更加细致。 &emsp;&emsp;在YML中可配置的Hystrix信息，和Properties中配置的内容是一致。 &emsp;&emsp;如果需要对每个服务做定制化配置，建议使用yml配置文件。在语法和格式上更容易管理和维护。 3.3 代码实现 - Factory实现方式&emsp;&emsp;在服务接口的@FeignClient注解中，不再使用fallback属性，而是定义fallbackFactory属性。这个属性的类型是Class类型的，用于配置fallback代码所处的Factory。 &emsp;&emsp;再定义一个Java类，实现接口FallbackFactory，实现其中的create方法。使用匿名内部类的方式，为服务接口定义一个实现类，定义fallback方法实现。 &emsp;&emsp;本地接口定义： &emsp;&emsp;FallbackFactory实现类： &emsp;&emsp;这种实现逻辑的优势是，可以获取远程调用服务的异常信息。为后期异常处理提供参考。 &emsp;&emsp;工厂实现方案和实现类的实现方案，没有效率和逻辑上的优缺点对比。只是在远程服务调用异常的处理上有区别。 4 Hystrix Dashboard - 数据监控 &emsp;&emsp;Hystrix dashboard是一款针对Hystrix进行实时监控的工具，通过Hystrix Dashboard我们可以在直观地看到各Hystrix Command的请求响应时间, 请求成功率等数据。 4.1 实现单服务单节点数据监控&emsp;&emsp;在使用了Hystrix技术的application client工程中增加下述依赖： &emsp;&emsp;在启动器上增加注解@EnableHystrixDashboard、@EnableHystrix。 &emsp;&emsp;启动工程后，如果触发了Hystrix，则可以通过得到监控数据。这种监控数据的获取都是JSON数据。 &emsp;&emsp;且数据量级较大。不易于查看。可以使用Hystrix Dashboard提供的视图界面来观察监控结果。视图界面访问路径为。视图界面中各数据的含义如下： 建议：监控中心建议使用独立工程来实现。这样更便于维护。 4.2 使用Turbine实现多服务或集群的数据监控&emsp;&emsp;Turbine是聚合服务器发送事件流数据的一个工具，hystrix的监控中，只能监控单个服务或单个节点，实际生产中都为多服务集群，因此可以通过turbine来监控多集群服务。 &emsp;&emsp;Turbine在Hystrix Dashboard中的作用如下： 4.2.1多服务监控&emsp;&emsp;当使用Turbine来监控多服务状态时，需提供一个独立工程来搭建Turbine服务逻辑。并在工程中增加下述依赖： &emsp;&emsp;并在全局配置文件中增加下述配置： &emsp;&emsp;在应用启动类中，增加注解@EnableTurbine，代表开启Turbine服务，提供多服务集群监控数据收集。 &emsp;&emsp;最后再Hystrix Dashboard视图监控服务中，使用作为监控数据来源，提供可视化监控界面 注意：使用Turbine做多服务监控的时候，要求全局配置文件中配置的服务列表命名在Eureka注册中心中可见。就是先启动Application client再启动Turbine。 4.2.2服务集群监控&emsp;&emsp;在spring cloud中，服务名相同的多服务结点会自动形成集群，并提供服务。在Turbine中，监控服务集群不需要提供任何的特殊配置，因为turbine.appConfig已经配置了要监控的服务名称。集群监控数据会自动收集。 &emsp;&emsp;在Hystrix Dashboard的可视化监控界面中，hosts信息会显示出服务集群中的节点数量。如图所示： 注意：使用Turbine做服务集群监控的时候，必须先启动application client集群，再启动Turbine。保证Turbine启动的时候，可以在eureka注册中心中发现要监控的服务集群。 "},{"title":"索引失效","date":"2021-04-02T03:13:19.000Z","url":"/2021/04/02/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/","tags":[["Sql","/tags/Sql/"],["Index","/tags/Index/"]],"categories":[["Sql","/categories/Sql/"]],"content":" 本文摘自： 番茄发烧了 &emsp;&emsp;虽然你这列上建了索引，查询条件也是索引列，但最终执行计划没有走它的索引。下面是引起这种问题的几个关键点。 列与列对比&emsp;&emsp;某个表中，有两列（id和c_id）都建了单独索引，下面这种查询条件不会走索引。 &emsp;&emsp;这种情况会被认为还不如走全表扫描。 存在NULL值条件&emsp;&emsp;我们在设计数据库表时，应该尽力避免NULL值出现，如果非要不可避免的要出现NULL值，也要给一个DEFAULT值，数值型可以给0、-1之类的， 字符串有时候给空串有问题，就给一个空格或其他。 &emsp;&emsp;如果索引列是可空的，很可能是不会给其建索引的，索引值是少于表的count(*)值的，所以这种情况下，执行计划自然就去扫描全表了。 NOT条件&emsp;&emsp;我们知道建立索引时，给每一个索引列建立一个条目，如果查询条件为等值或范围查询时，索引可以根据查询条件去找对应的条目。 &emsp;&emsp;反过来当查询条件为非时，索引定位就困难了，执行计划此时可能更倾向于全表扫描，这类的查询条件有：&lt;&gt;、NOT、in、not exists LIKE通配符&emsp;&emsp;当使用模糊搜索时，尽量采用后置的通配符，例如：name||’%’，因为走索引时，其会从前去匹配索引列，这时候是可以找到的，如果采用前匹配，那么查索引就会很麻烦，比如查询所有姓张的人，就可以去搜索’张%’。 &emsp;&emsp;相反如果你查询所有叫‘明’的人，那么只能是%明。这时候索引如何定位呢？前匹配的情况下，执行计划会更倾向于选择全表扫描。后匹配可以走INDEX RANGE SCAN。 &emsp;&emsp;所以业务设计的时候，尽量考虑到模糊搜索的问题，要更多的使用后置通配符。 条件上包括函数&emsp;&emsp;查询条件上尽量不要对索引列使用函数，比如下面这个SQL. &emsp;&emsp;这样是不会走索引的，因为索引在建立时会和计算后可能不同，无法定位到索引。但如果查询条件不是对索引列进行计算，那么依然可以走索引。比如 &emsp;&emsp;这样的函数还有：to_char、to_date、to_number、trunc等。 复合索引前导列区分大&emsp;&emsp;当复合索引前导列区分小的时候，我们有INDEX SKIP SCAN，当前导列区分度大，且查后导列的时候，前导列的分裂会非常耗资源，执行计划想，还不如全表扫描来的快，然后就索引失效了。 数据类型的转换&emsp;&emsp;当查询条件存在隐式转换时，索引会失效。 &emsp;&emsp;比如在数据库里id存的number类型，但是在查询时，却用了下面的形式： Connect By Level&emsp;&emsp;使用connect by level时，不会走索引。 谓词运算&emsp;&emsp;我们在上面说，不能对索引列进行函数运算，这也包括加减乘除的谓词运算，这也会使索引失效。 &emsp;&emsp;建立一个sunyang表，索引为id，看这个SQL： &emsp;&emsp;这里很明显对索引列id进行了’/2’除二运算，这时候就会索引失效，这种情况应该改写为： &emsp;&emsp;就可以使用索引了。 Vistual Index&emsp;&emsp;先说明一下，虚拟索引的建立是否有用，需要看具体的执行计划，如果起作用就可以建一个，如果不起作用就算了。普通索引这么建： &emsp;&emsp;虚拟索引Vistual Index这么建： &emsp;&emsp;做了一个实验，首先创建一个表： &emsp;&emsp;其中id为普通索引，a为虚拟索引。 &emsp;&emsp;在表中插入十万条数据 &emsp;&emsp;接着分别去执行下面的SQL看时间，由于在内网机做实验，图贴不出来，数据保证真实性。 &emsp;&emsp;因为在执行过一次后，oracle对结果集缓存了，所以第二次执行耗时不走索引，走内存就都一样了。 &emsp;&emsp;可以看到在这种情况下，虚拟索引比普通索引快了一倍。 &emsp;&emsp;具体虚拟索引的使用细节，这里不再展开讨论。 Invisible Index&emsp;&emsp;Invisible Index是oracle 11g提供的新功能，对优化器（还接到前面博客里讲到的CBO吗）不可见，MySQL 也有，MySQL 8.0 中的索引可以隐藏了。我感觉这个功能更主要的是测试用，假如一个表上有那么多索引，一个一个去看执行计划调试就很慢了，这时候不如建一个对表和查询都没有影响的Invisible Index来进行调试，就显得很好了。 &emsp;&emsp;通过下面的语句来操作索引 &emsp;&emsp;如果想让CBO看到Invisible Index，需要加入这句： "},{"title":"SpringCloud组件：Ribbon的负载均衡策略及原理","date":"2021-04-01T09:15:03.000Z","url":"/2021/04/01/Ribbon%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E5%8F%8A%E5%8E%9F%E7%90%86/","tags":[["SpringCloud","/tags/SpringCloud/"],["Ribbon","/tags/Ribbon/"]],"categories":[["SpringCloud","/categories/SpringCloud/"]],"content":" 本文章摘抄自网站博客，纯属兴趣摘抄自本博客 &emsp;&emsp;Load Balance负载均衡是用于解决一台机器(一个进程)无法解决所有请求而产生的一种算法。像nginx可以使用负载均衡分配流量，ribbon为客户端提供负载均衡，dubbo服务调用里的负载均衡等等，很多地方都使用到了负载均衡。&emsp;&emsp;使用负载均衡带来的好处很明显： 当集群里的1台或者多台服务器down的时候，剩余的没有down的服务器可以保证服务的继续使用 使用了更多的机器保证了机器的良性使用，不会由于某一高峰时刻导致系统cpu急剧上升&emsp;&emsp;负载均衡有好几种实现策略，常见的有： 随机 (Random) 轮询 (RoundRobin) 一致性哈希 (ConsistentHash) 哈希 (Hash) 加权（Weighted） ILoadBalance 负载均衡器 &emsp;&emsp;ribbon是一个为客户端提供负载均衡功能的服务，它内部提供了一个叫做ILoadBalance的接口代表负载均衡器的操作，比如有添加服务器操作、选择服务器操作、获取所有的服务器列表、获取可用的服务器列表等等。 &emsp;&emsp;ILoadBalance的继承关系如下： &emsp;&emsp;负载均衡器是从EurekaClient（EurekaClient的实现类为DiscoveryClient）获取服务信息，根据IRule去路由，并且根据IPing判断服务的可用性。 &emsp;&emsp;负载均衡器多久一次去获取一次从Eureka Client获取注册信息呢？在BaseLoadBalancer类下，BaseLoadBalancer的构造函数，该构造函数开启了一个PingTask任务setupPingTask();，代码如下： &emsp;&emsp;setupPingTask()的具体代码逻辑，它开启了ShutdownEnabledTimer执行PingTask任务，在默认情况下pingIntervalSeconds为10，即每10秒钟，向EurekaClient发送一次”ping”。 &emsp;&emsp;PingTask源码，即new一个Pinger对象，并执行runPinger()方法。 &emsp;&emsp;查看Pinger的runPinger()方法，最终根据 pingerStrategy.pingServers(ping, allServers)来获取服务的可用性，如果该返回结果，如之前相同，则不去向EurekaClient获取注册列表，如果不同则通知ServerStatusChangeListener或者changeListeners发生了改变，进行更新或者重新拉取。 完整过程是： &emsp;&emsp;LoadBalancerClient（RibbonLoadBalancerClient是实现类）在初始化的时候（execute方法），会通过ILoadBalance（BaseLoadBalancer是实现类）向Eureka注册中心获取服务注册列表，并且每10s一次向EurekaClient发送“ping”，来判断服务的可用性，如果服务的可用性发生了改变或者服务数量和之前的不一致，则从注册中心更新或者重新拉取。LoadBalancerClient有了这些服务注册列表，就可以根据具体的IRule来进行负载均衡。 IRule 路由 &emsp;&emsp;IRule接口代表负载均衡策略： &emsp;&emsp;IRule接口的实现类有以下几种： &emsp;&emsp;其中RandomRule表示随机策略、RoundRobinRule表示轮询策略、WeightedResponseTimeRule表示加权策略、BestAvailableRule表示请求数最少策略等等。 &emsp;&emsp;随机策略很简单，就是从服务器中随机选择一个服务器，RandomRule的实现代码如下： &emsp;&emsp;RoundRobinRule轮询策略表示每次都取下一个服务器，比如一共有5台服务器，第1次取第1台，第2次取第2台，第3次取第3台，以此类推： &emsp;&emsp;WeightedResponseTimeRule继承了RoundRobinRule，开始的时候还没有权重列表，采用父类的轮询方式，有一个默认每30秒更新一次权重列表的定时任务，该定时任务会根据实例的响应时间来更新权重列表，choose方法做的事情就是，用一个(0,1)的随机double数乘以最大的权重得到randomWeight，然后遍历权重列表，找出第一个比randomWeight大的实例下标，然后返回该实例，代码略。 &emsp;&emsp;BestAvailableRule策略用来选取最少并发量请求的服务器： &emsp;&emsp;使用Ribbon提供的负载均衡策略很简单，只需以下几部： 1、创建具有负载均衡功能的RestTemplate实例 &emsp;&emsp;使用RestTemplate进行rest操作的时候，会自动使用负载均衡策略，它内部会在RestTemplate中加入LoadBalancerInterceptor这个拦截器，这个拦截器的作用就是使用负载均衡。 &emsp;&emsp;默认情况下会采用轮询策略，如果希望采用其它策略，则指定IRule实现，如： &emsp;&emsp;这种方式对Feign也有效。 &emsp;&emsp;我们也可以参考ribbon，自己写一个负载均衡实现类。 &emsp;&emsp;可以通过下面方法获取负载均衡策略最终选择了哪个服务实例： "},{"title":"事务注解@Transactional失效的3种场景及解决办法","date":"2021-03-31T06:16:48.000Z","url":"/2021/03/31/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional%E5%A4%B1%E6%95%88%E7%9A%843%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","tags":[["Spring","/tags/Spring/"],["Annotation","/tags/Annotation/"],["Transactional","/tags/Transactional/"]],"categories":[["Spring","/categories/Spring/"]],"content":" 本问引用自博客： 一撸向北 一、Transactional失效场景介绍第一种&emsp;&emsp;Transactional注解标注方法修饰符为非public时，@Transactional注解将会不起作用，例如以下代码，定义一个错误的@Transactional标注实现，修饰一个默认访问符的方法 &emsp;&emsp;在同一个包内，新建调用对象，进行访问。 &emsp;&emsp;测试用例 &emsp;&emsp;以上的访问方式，导致事务没开启，因此在方法抛出异常时，testMapper.insert(new Test(10,20,30));操作不会进行回滚。如果TestServiceImpl#insertTestWrongModifier方法由default改为public的话将会正常开启事务，testMapper.insert(new Test(10,20,30));将会进行回滚。 第二种&emsp;&emsp;在类内部调用调用同一类内部@Transactional标注的方法。这种情况下也会导致事务不开启。示例代码如下，设置一个内部调用 &emsp;&emsp;测试用例 &emsp;&emsp;上面就是使用的测试代码，运行测试知道，外部调用事务方法能够征程开启事务，testMapper.insert(new Test(10,20,30))操作将会被回滚； &emsp;&emsp;然后运行另外一个测试用例，调用一个方法在类内部调用内部被@Transactional标注的事务方法，运行结果是事务不会正常开启，testMapper.insert(new Test(10,20,30))操作将会保存到数据库不会进行回滚。 第三种&emsp;emsp;事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。示例代码如下: &emsp;&emsp;测试代码如下： &emsp;&emsp;运行测试用例发现，虽然抛出异常，但是异常被捕捉了，没有抛出到方法 外， testMapper.insert(new Test(210,20,30))操作并没有回滚。 &emsp;&emsp;以上三种就是@Transactional注解不起作用，@Transactional注解失效的主要原因。下面结合spring中对于@Transactional的注解实现源码分析为何导致@Transactional注解不起作用。 二、**@Transactional注解不起作用原理分析**第一种&emsp;&emsp;@Transactional注解标注方法修饰符为非public时，@Transactional注解将会不起作用。这里分析 的原因是，@Transactional是基于动态代理实现的，@Transactional注解实现原理中分析了实现方法，在bean初始化过程中，对含有@Transactional标注的bean实例创建代理对象，这里就存在一个spring扫描@Transactional注解信息的过程，不幸的是源码中体现，标注@Transactional的方法如果修饰符不是public，那么就默认方法的@Transactional信息为空，那么将不会对bean进行代理对象创建或者不会对方法进行代理调用 &emsp;&emsp;@Transactional注解实现原理中，介绍了如何判定一个bean是否创建代理对象，大概逻辑是，根据spring创建好一个aop切点BeanFactoryTransactionAttributeSourceAdvisor实例，遍历当前bean的class的方法对象，判断方法上面的注解信息是否包含@Transactional，如果bean任何一个方法包含@Transactional注解信息，那么就是适配这个BeanFactoryTransactionAttributeSourceAdvisor切点。则需要创建代理对象，然后代理逻辑为我们管理事务开闭逻辑。 &emsp;&emsp;spring源码中，在拦截bean的创建过程，寻找bean适配的切点时，运用到下面的方法，目的就是寻找方法上面的@Transactional信息，如果有，就表示切点BeanFactoryTransactionAttributeSourceAdvisor能够应用（canApply）到bean中，AopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class&lt;?&gt;, boolean)。 &emsp;&emsp;我们可以在上面的方法打断点，一步一步调试跟踪代码，最终上面的代码还会调用如下方法来判断。在下面的方法上断点，回头看看方法调用堆栈也是不错的方式跟踪。推荐： &emsp;&emsp;AbstractFallbackTransactionAttributeSource#getTransactionAttribute &emsp;&emsp;AbstractFallbackTransactionAttributeSource#computeTransactionAttribute 不创建代理对象&emsp;&emsp;所以，如果所有方法上的修饰符都是非public的时候，那么将不会创建代理对象。以一开始的测试代码为例，如果正常的修饰符的testService是下面图片中的，经过cglib创建的代理对象。 &emsp;&emsp;如果class中的方法都是非public的那么将不是代理对象。 不进行代理调用&emsp;&emsp;考虑一种情况，如下面代码所示。两个方法都被@Transactional注解标注，但是一个有public修饰符一个没有，那么这种情况我们可以预见的话，一定会创建代理对象，因为至少有一个public修饰符的@Transactional注解标注方法。 &emsp;&emsp;创建了代理对象，insertTestWrongModifier就会开启事务吗？答案是不会。 &emsp;&emsp;原因是在动态代理对象进行代理逻辑调用时，在cglib创建的代理对象的拦截函数中CglibAopProxy.DynamicAdvisedInterceptor#intercept，有一个逻辑如下，目的是获取当前被代理对象的当前需要执行的method适配的aop逻辑。 &emsp;&emsp;而针对@Transactional注解查找aop逻辑过程，相似地，也是执行一次 &emsp;&emsp;AbstractFallbackTransactionAttributeSource#getTransactionAttribute&emsp;&emsp;AbstractFallbackTransactionAttributeSource#computeTransactionAttribute 也就是说还需要找一个方法上的@Transactional注解信息，没有的话就不执行代理@Transactional对应的代理逻辑，直接执行方法。没有了@Transactional注解代理逻辑，就无法开启事务，这也是上一篇已经讲到的。 第二种&emsp;&emsp;在类内部调用调用类内部@Transactional标注的方法。这种情况下也会导致事务不开启。 &emsp;&emsp;经过对第一种的详细分析，对这种情况为何不开启事务管理，原因应该也能猜到； &emsp;&emsp;既然事务管理是基于动态代理对象的代理逻辑实现的，那么如果在类内部调用类内部的事务方法，这个调用事务方法的过程并不是通过代理对象来调用的，而是直接通过this对象来调用方法，绕过的代理对象，肯定就是没有代理逻辑了。 &emsp;&emsp;其实我们可以这样玩，内部调用也能实现开启事务，代码如下。 &emsp;&emsp;上面就是使用了代理对象进行事务调用，所以能够开启事务管理，但是实际操作中，没人会闲的蛋疼这样子玩。 第三种&emsp;&emsp;事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。 &emsp;&emsp;这种的话，可能我们比较常见，问题就出在代理逻辑中，我们先看看源码里面动态代理逻辑是如何为我们管理事务的。 &emsp;&emsp;TransactionAspectSupport#invokeWithinTransaction &emsp;&emsp;代码如下: &emsp;&emsp;所以看了上面的代码就一目了然了，事务想要回滚，必须能够在这里捕捉到异常才行，如果异常中途被捕捉掉，那么事务将不会回滚。 &emsp;&emsp;总结了以上几种情况。"},{"title":"objective","date":"2021-03-29T03:39:46.000Z","url":"/2021/03/29/objective/","tags":[["target","/tags/target/"]],"categories":[["日常计划","/categories/%E6%97%A5%E5%B8%B8%E8%AE%A1%E5%88%92/"]],"content":"1.短期目标：第一阶段1.1 输出Spring Security 原理文档（简单讲解，后续会陆续增加详细说明，在后续目标中再确定）1.2 输出Spring Security Demo学习文档（包含简单的源码讲解）1.3 输出Spring Security核心源码学习文档1.4 学习OAuth2.0框架1.5 输出OAuth2.0原理文档…… 每日目标 保证每日更新博客内容 "},{"title":"Spring Security Demo 学习","date":"2021-03-24T16:00:00.000Z","url":"/2021/03/25/SpringSecurityDemoStudy/","tags":[["demo","/tags/demo/"],["Spring Security","/tags/Spring-Security/"],["Spring Boot","/tags/Spring-Boot/"]],"categories":[["Spring Security","/categories/Spring-Security/"]],"content":" 本问主要基于Spring boot框架进行Demo说明，首先创建一个Springboot 工程。 1.创建Springboot 工程2.引入Spring Security 依赖&emsp;&emsp;我们可以直接引入Spring Security 的starter包 &emsp;&emsp;当我们查看spring-boot-starter-security引入的依赖时，我们可以看到starter主要引入了Spring Security的spring-security-config和spring-security-web包，我们也可以手动引入这两个包 3.Demo学习3.1Spring Security默认配置&emsp;&emsp;我们建立的Spring boot工程默认端口号为8080，在引入Spring Security包之前，启动服务，访问;此时页面显示404，无法找到页面；此时我们在将Spring Security的依赖引入，重启服务，再次访问服务，此时我们可以看到如下页面： &emsp;&emsp;这是一个表单认证的登录页面，也就是说当引入Spring Security依赖后，服务就已经开启Spring Security的认证功能，那既然Spring Security既然引入依赖后就默认开启了认证功能，是不是就有默认的用户名和密码？其实Spring Security中有一个SecurityProperties配置类中的一个静态内部类中告诉了我们默认的用户名和密码，可以看到默认用户名和密码分别是user和uuid生成的一串随机码，此时我们只能明确一个用户名是user，密码的随机字符串我们却不知道。 &emsp;&emsp;此时我们查看这个内部类被谁调用过，是不是可以从调用处能够看到默认密码的信息，当我们查看调用方时，我们可以看到一个类名：UserDetailsServiceAutoConfiguration的类，如果认真看服务启动时打印的信息的话，可以看到控制台其实打印了这个类的信息： &emsp;&emsp;查看这个类的代码： &emsp;&emsp;在这个类的注释可以知道，这个自动配置类时记忆了一个默认的用户，在定义AuthenticationManager、AuthenticationProvider、UserDetailsService中任一类时，这个自动配置类会被禁用。&emsp;&emsp;我们可以看到在这个类的getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder)方法中通过日志的方式打印了密码的信息，那我们在看看之前截截图中打印的控制台信息，第二处标红就是上述类方法中打印的密码信息，此时我们已经知道了Spring Security在配置用户名和密码的情况下默认的用户密码为user和控制台打印出的随机码。&emsp;&emsp;此时我们再访问 ,输入默认的用户名和密码，此时点击Sign in按钮后，页面跳转依然显示404，其实Spring Security已经验证了信息，这个404是我们未定义访问的接口返回的信息或需要跳转的页面。&emsp;&emsp;我们可以定义一下访问接口的，在这之前我们先通过配置文件修改一下我们当前的用户名和密码，在配置文件中增加如下配置： &emsp;&emsp;重启服务，发现此前控制台打印的UserDetailsServiceAutoConfiguration信息和随机密码在控制台已经不打印了，此时我们在登录页输入我们配置的用户名和密码，发现效果和之前相同，但因为我们没有配置接口信息，无法确认验证是否进行及配置是否生效。&emsp;&emsp;我们在服务中建一个测试的Controller &emsp;&emsp;此时我们重启服务再去页面登录后查看效果，此时页面展示了我们接口中定义的Hello World的字符串，但此时是否说明我们Spring Security已经验证成功？还是说Spring Security没有做认证，只是提供了登录页面无论输入什么用户名和密码都会成功呢？？我们返回登录页面，输入一个错误的用户名或者密码来验证一下。&emsp;&emsp;当我们输入错误的用户名或者密码时，我们可以看到页面并未跳转且登录页面显示“用户名或密码错误”，此时可以说明Spring Security已经对我们的请求进行了简单的认证。&emsp;&emsp;但我们现在只是验证了引入了Spring Security的默认配置，但我们实际使用中需要做到Spring Security 的可配置，以适应我们项目的需求，Spring Security本身和Spring框架一样，提供了框架了可扩展性，所以后续过程中，我们就要实现的Spring Security的扩展性配置。 3.2 Spring Security 配置&emsp;&emsp;要使用Spring Security的认证和鉴权功能以满足我们的产品，我们就需要知道如何去配置Spring Security以满足我们的需求使用。&emsp;&emsp;根据Spring Security官网介绍，完成Spring Seccurity配置需要继承"},{"title":"SpringSecurity原理","date":"2021-03-02T09:07:54.000Z","url":"/2021/03/02/SpringSecurity%E5%8E%9F%E7%90%86/","tags":[["spring security","/tags/spring-security/"]],"categories":[["Spring Security","/categories/Spring-Security/"]],"content":"SpringSecurity原理一、SpringSecurity过滤器链 SpringSecurity的底层实现是一条过滤器链，也就是说用户进来后，由这些过滤器链判断是否有请求的权限，如果有权限则放过；没有权限的化就会抛出异常，重定向到要跳转的页面 SpringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤器链的各个进行说明:&emsp;&emsp;2.1 WebAsyncManagerIntegrationFilter：将Security上下文与Spring Web中用于处理异步请求映射的WebAsyncManager进行集成;&emsp;&emsp;2.2 SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个”仓储”中，然后将SecurityContextHolder中的信息清除，例如：在Session中维护一个用户的安全信息就是这个过滤器处理的;&emsp;&emsp;2.3HeaderWriterFilter：用于将头信息加入到响应中;&emsp;&emsp;2.4 CsrfFilter：用于处理跨站请求伪造;&emsp;&emsp;2.5 LogoutFilter：用于处理退出登录;&emsp;&emsp;2.6 UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自/login的请求。从表单中获取用户名和密码时，默认使用的name的值为username和password，这两个值可以通过设置这个过滤器的usernameParameter和passwordParameter两个参数的值进行修改。&emsp;&emsp;2.7 DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且在需要进行登陆时生成一个登录表单页面。&emsp;&emsp;2.8 BasicAuthenticationFilter：检测和处理http basic认证。&emsp;&emsp;2.9 RequestCacheAwareFilter：用来处理请求的缓存。&emsp;&emsp;2.10 SecurityContextHolderAwareRequestFilter：主要包装请求的Requeest。&emsp;&emsp;2.11 AnonymousAuthenticationFilter： 检测SecurityContextHolder中是否存在Authentication对象，如果不存在为其提供一个匿名Authentication。&emsp;&emsp;2.12 SessionManagementFilter：管理session的过滤器。&emsp;&emsp;2.13 ExceptionTranslationFilter：处理AccessDeniedException和AuthenticationException异常。&emsp;&emsp;2.14 FilterSecurityInterceptor：过滤器链的出口。&emsp;&emsp;2.15 RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时，从cookie中找出用户的信息，如果Spring Security能够识别出用户提供的remember me cookie,用户将不必填写用户名和密码，而是直接登录进入系统，该过滤器默认不开启。二、SpringSecurity流程图(如链接中流程图)&emsp;&emsp;SpringSecurity流程图 三、SpringSecurity流程说明 客户端发起请求，进入过滤器链 当到LogoutFilter的时候判断是否是登出路径，如果是登出路径则到LogoutHandler，如果登出成功则到logoutSuccessHandler登出成功处理，如果登出失败则由ExceptionTranslationFilter，如果不是登出路径则直接进入下一个过滤器。 当到UsernamePasswordAuthenticationFilter的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到AuthenticationFailureHandler登录失败处理器处理，如果登录成功则到AuthenticationSuccessHandler登录成功处理器处理，如果不是登录请求则不进入该过滤器。 当到FilterSecurityInterceptor的时候会拿到uri，根据uri去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到Controller层否则到AccessDeniedHandler鉴权失败处理器处理。四、SpringSecurity配置(简单介绍，详细使用方案会在后续使用文档中说明，本文档主要是介绍文档)&emsp;&emsp;Springboot需要在WebSecurityconfigurerAdapter这个类中实现上述流程图的配置，代码中需要实现这个类并重写其中需要使用的方法配置伪代码 配置简介&emsp;&emsp;config(AuthenticationManagerBuilder auth) 配置Security认证的方法，AuthenticationManagerBuilder见明知义，就是构建一个Authentication的管理器，该类的功能参考SpringSecurity流程图中AuthenticationManager部分所示，该部分可以配置UserDetailsService和PasswordEncoder。UserDetailsService用于在认证器中根据用户传过来的用户名查找一个用户，在使用过程中，可以实现该接口，重写其中的方法，加载一个UserDeatils信息，认证通过后就会将该对象赋给认证通过的Authentication的Principal对象，后续需要对象信息时就通过SecurityContextHolder获取存放在SecurityContext中的Authentication的principal。PasswordEncoder用于密码的加密与比对，可以自定义加密方法。&emsp;&emsp;configure(WebSecurity web) 配置静态资源的权限。&emsp;&emsp;config(HttpSecurity http) 这个配置方法是WebSecurityConfigurerAdapter的核心配置方法，每个配置我们可以分开说明。 &emsp;&emsp;此段代码配置了登录页请求路径，密码属性名，用户名属性名，和登录请求路径,permitAll()代表任意用户可访问。 ​ 此段代码是对权限的配置，这段代码表示访问/test的URL时需要有test的权限方可访问，anyRequest() 表示任意请求，authenticated()表示需要通过认证，accessDecisionManager() 表示绑定在url上的鉴权管理器。 &emsp;&emsp;用户登出时的相关配置，new MyLogoutSuccessHandler()登出成功后的处理，可自定义。 &emsp;&emsp;此段代码是关闭csrf。 &emsp;&emsp;此段代码是配置鉴权失败的处理器。 &emsp;&emsp;代码展示如何在过滤器链中插入自己的过滤器，addFilterBefore加在对应的过滤器之前，addFilterAfter加在对应的过滤器之后，addFilterAt加在过滤器同一位置，事实上框架原有的Filter在启动HttpSecurity配置的过程中，都由框架完成了其一定程度上固定的配置，是不允许更改替换的。根据测试结果来看，调用addFilterAt方法插入的Filter，会在这个位置上的原有Filter之前执行。 五、SpringSecurity权限系统UserDeatils&emsp;&emsp;SpringSecurity定义的用户接口，当我们需要自定义一些属性时，需要实现该接口。 GrantedAuthority&emsp;&emsp;SpringSecurity定义的用户权限接口，自定义权限需要实现该接口。 &emsp;&emsp;authority是权限字段，需要注意的是在config中配置的权限会被加上ROLE_前缀，比如我们的配置authorizeRequests().antMatchers(&quot;/test&quot;).hasRole(&quot;test&quot;)，配置了一个test权限但我们存储的权限字段（authority）应该是ROLE_test。 UserDetailsService&emsp;&emsp;Security中的用户Service，自定义用户服务类需要实现该接口,我们在loadUserByUsername中根据传入的用户名查询我们当前系统对应该对象的用户名和权限，构造UserDetails对象，再有框架去验证传入的对象信息和我们系统的对象信息是否一致。 SecurityContextHolder&emsp;&emsp;用户在完成登录后 Security 会将用户信息存储到这个类中，之后其他流程需要得到用户信息时都是从这个类中获得，用户信息被封装成 SecurityContext ，而实际存储的类是SecurityContextHolderStrategy，默认的SecurityContextHolderStrategy 实现类是 ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。&emsp;&emsp;手动填充 SecurityContextHolder 示例： &emsp;&emsp;对于使用 token 鉴权的系统，我们就可以验证token后手动填充SecurityContextHolder，填充时机只要在执行投票器之前即可，或者干脆可以在投票器中填充，然后在登出操作中清空SecurityContextHolder。 Security扩展&emsp;&emsp;可扩展的部分有: &emsp;&emsp;1.鉴权失败处理器&emsp;&emsp;Security 鉴权失败默认跳转登录页面，我们可以实现AccessDeniedHandler接口，重写 handle() 方法来自定义处理逻辑；然后参考配置类说明将处理器加入到配置当中。 &emsp;&emsp;2.验证器&emsp;&emsp;实现 AuthenticationProvider 接口来实现自己验证逻辑。需要注意的是在这个类里面就算你抛出异常，也不会中断验证流程，而是算你验证失败，我们由流程图知道，只要有一个验证器验证成功，就算验证成功，所以你需要留意这一点。 &emsp;&emsp;3.登录成功处理器&emsp;&emsp;在Security中验证成功默认跳转到上一次请求页面或者路径为 “/“ 的页面，我们同样可以自定义：继承SimpleUrlAuthenticationSuccessHandler这个类或者实现AuthenticationSuccessHandler接口。我这里建议采用继承的方式,SimpleUrlAuthenticationSuccessHandler是默认的处理器，采用继承可以契合里氏替换原则，提高代码的复用性和避免不必要的错误。 &emsp;&emsp;4.投票器&emsp;&emsp;投票器可继承WebExpressionVoter或者实现 AccessDecisionVoter接口；WebExpressionVoter是Security默认的投票器；我这里同样建议采用继承的方式；添加到配置的方式参考上文；&emsp;&emsp;注意：投票器 vote 方法返回一个int值；-1代表反对，0代表弃权，1代表赞成；投票管理器收集投票结果，如果最终结果大于等于0则放行该请求。 &emsp;&emsp;5.自定义token处理过滤器&emsp;&emsp;自定义 token 处理器继承自 OncePerRequestFilter 或者 GenericFilterBean 或者 Filter 都可以，在这个处理器里面需要完成的逻辑是：获取请求里的 token，验证 token 是否合法然后填充 SecurityContextHolder ，虽然说过滤器只要添加在投票器之前就可以，但我这里还是建议添加在 http.addFilterAfter(new MyFittler(), LogoutFilter.class); &emsp;&emsp;6.登出成功处理器&emsp;&emsp;实现LogoutSuccessHandler接口，添加到配置的方式参考上文。 &emsp;&emsp;7.登出失败处理器&emsp;&emsp;登录失败默认跳转到登录页，我们同样可以自定义。继承SimpleUrlAuthenticationFailureHandler 或者实现 AuthenticationFailureHandler。 &emsp;&emsp;8.自定义UsernamePasswordAuthenticationFilter&emsp;&emsp;我们自定义UsernamePasswordAuthenticationFilter可以极大提高我们Security的灵活性（比如添加验证验证码是否正确的功能）。我们直接继承UsernamePasswordAuthenticationFilter，然后在配置类中初始化这个过滤器，给这个过滤器添加登录失败处理器，登录成功处理器，登录管理器，登录请求url 。 &emsp;&emsp;示例代码 六、总结&emsp;&emsp;对于Security的扩展配置关键在于configure(HttpSecurityhttp)方法；扩展认证方式可以自定义authenticationManager并加入自己验证器，在验证器中抛出异常不会终止验证流程；扩展鉴权方式可以自定义accessDecisionManager然后添加自己的投票器并绑定到对应的url（url 匹配方式为 ant）上，投票器vote(Authenticationauthentication,FilterInvocationfi,Collection&lt;ConfigAttribute&gt;attributes) 方法返回值为三种：-1 0 1，分别表示反对弃权赞成。 &emsp;&emsp;对于token认证的校验方式，可以暴露一个获取的接口，或者重写UsernamePasswordAuthenticationFilter过滤器和扩展登录成功处理器来获取token，然后在LogoutFilter之后添加一个自定义过滤器，用于校验和填充SecurityContextHolder。 &emsp;&emsp;另外，Security的处理器大部分都是重定向的，我们的项目如果是前后端分离的话，我们希望无论什么情况都返回json,那么就需要重写各个处理器了。"}]