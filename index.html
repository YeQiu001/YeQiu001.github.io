<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>YeQiu Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="叶湫的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="YeQiu Blog">
<meta property="og:url" content="https://yeqiu001.github.io/index.html">
<meta property="og:site_name" content="YeQiu Blog">
<meta property="og:description" content="叶湫的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="YeQiu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="YeQiu Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">YeQiu Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">落暮寒鸦添秋意,小桥流水任寂寥</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yeqiu001.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-SpringBoot定时任务和异步线程池" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/SpringBoot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:04:45.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Springboot/">Springboot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/SpringBoot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/">SpringBoot定时任务和异步线程池</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>博客地址: <a target="_blank" rel="noopener" href="https://blog.csdn.net/xuan_lu/article/details/110568508"><em>溪~源</em></a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/coHXw9"><img src="https://z3.ax1x.com/2021/04/19/coHXw9.jpg" alt="coHXw9.jpg"></a></p>
<p>项目中最近使用了多个定时任务处理业务需求，于是在实现业务逻辑过程中，产生了上图一些思考和疑问，现在利用空余时间进行一次复盘。</p>
<h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p>项目搭建环境：JDK1.8+SpringBoot</p>
<p>主启动类：加上@EnableScheduling</p>
<p>新建定时任务配置类：ScheduledTask；定义两个定时任务，简单打印一下线程名字和时间戳</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledTask1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---scheduledTask1 &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledTask2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---scheduledTask2 &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一、多任务串行执行"><a href="#一、多任务串行执行" class="headerlink" title="一、多任务串行执行"></a>一、多任务串行执行</h3><h4 id="1-相同定时任务"><a href="#1-相同定时任务" class="headerlink" title="1.相同定时任务"></a>1.相同定时任务</h4><p>先解决多任务定时相同时间，是否存在优先级执行顺序，执行上面的代码，打印日志如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/cTP5xH"><img src="https://z3.ax1x.com/2021/04/19/cTP5xH.jpg" alt="cTP5xH.jpg"></a></p>
<p>从控制台日志发现，两个定时任务并没有存在一定的执行顺序，存在乱序现象。</p>
<p>故：串行定时任务，没有明显的优先级关系。</p>
<h4 id="2-一个定时任务阻塞"><a href="#2-一个定时任务阻塞" class="headerlink" title="2.一个定时任务阻塞"></a>2.一个定时任务阻塞</h4><p>​    为了实现此场景的条件，将定时任务1中添加死循环逻辑。源码改动如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledTask1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---scheduledTask1 &quot;</span> + System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/cTirY8"><img src="https://z3.ax1x.com/2021/04/19/cTirY8.jpg" alt="cTirY8.jpg"></a></p>
<p>从控制台可以得出：多个定时任务时串行执行的,如果一个任务出现阻塞，其他的任务都会受到影响。</p>
<h3 id="二、多任务并行执行"><a href="#二、多任务并行执行" class="headerlink" title="二、多任务并行执行"></a>二、多任务并行执行</h3><p>如果要实现并行执行，启动类需要在上面的基础上新增注解@EnableAsync。任务方法上新增@Async注解。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledTask1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---scheduledTask1 &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledTask2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---scheduledTask2 &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/cTFqC8"><img src="https://z3.ax1x.com/2021/04/19/cTFqC8.jpg" alt="cTFqC8.jpg"></a></p>
<p>从控制台中打印的线程名发现：每次执行任务时，都是创建新的线程执行，使用默认线程池SimpleAsyncTaskExecutor。</p>
<p>默认情况下异步调用使用的线程池是SimpleAsyncTaskExecutor，该线程池是不被推荐，因为该线程池的线程不重用，每次调用都会创建一个新的线程。所以需要我们自定义线程池。</p>
<h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><h4 id="1-自定义局部线程池"><a href="#1-自定义局部线程池" class="headerlink" title="1.自定义局部线程池"></a>1.自定义局部线程池</h4><p>局部线程池实际上就是指异步方法上需要指定使用该线程池，否则将使用默认线程池。</p>
<p>配置异步线程池源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskExecutorConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写AsyncTaskExecutor对象，实现全局异步线程，即<span class="doctag">@Async</span>注解需指定线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean(value = &quot;asyncTaskExecutor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncTaskExecutor <span class="title">asyncTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;defineAsyncTask-&quot;</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            线程池对拒绝任务的处理策略(rejection policy)：</span></span><br><span class="line"><span class="comment">            当线程池已经达到最大线程数量，没有空闲线程时，新任务该如何处理</span></span><br><span class="line"><span class="comment">            可选策略：</span></span><br><span class="line"><span class="comment">            CallerRunsPolicy:当线程池没有能力处理时直接在执行方法的调用线程中运行被拒绝的任务</span></span><br><span class="line"><span class="comment">            如果执行程序已经关闭，将丢弃该任务.</span></span><br><span class="line"><span class="comment">            AbortPolicy:处理程序遭到拒绝时将抛出 RejectedExecutionException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">//等待所有任务调度完成在关闭线程池，保证所有的任务被正确处理</span></span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//线程池关闭时等待其他任务的时间，不能无限等待，确保应用最后能被关闭。而不是无限期阻塞</span></span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="comment">//线程池初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时任务源码修改如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span></span><br><span class="line">    <span class="comment">//指定自定义线程池</span></span><br><span class="line">    <span class="meta">@Async(&quot;asyncTaskExecutor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledTask1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---scheduledTask1 &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span></span><br><span class="line">    <span class="meta">@Async</span><span class="comment">//未指定线程池，则使用默认线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledTask2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---scheduledTask2 &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台执行结果如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/cTxZef"><img src="https://z3.ax1x.com/2021/04/20/cTxZef.jpg" alt="cTxZef.jpg"></a></p>
<p>从图中依据线程名字，看到任务1均有自定义线程池<code>defineAsyncTask-*</code>执行，同时验证默认线程池SimpleAsyncTaskExecutor一直创建新线程执行。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/cTxaY4"><img src="https://z3.ax1x.com/2021/04/20/cTxaY4.jpg" alt="cTxaY4.jpg"></a></p>
<h4 id="2-定义全局线程池"><a href="#2-定义全局线程池" class="headerlink" title="2.定义全局线程池"></a>2.定义全局线程池</h4><p>上面需在@Async()注解中指定使用自定义线程池才有效，如果我们即不想指定线程池，又不想使用默认线程池池—全局线程池。</p>
<p>定义全局线程池可以通过实现 AsyncConfigurer 或者继承 AsyncConfigurerSupport。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncGlobalConfig</span> <span class="keyword">extends</span> <span class="title">AsyncConfigurerSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_PREFIX = <span class="string">&quot;defineGlobalAsync-&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setThreadNamePrefix(THREAD_PREFIX);</span><br><span class="line">        executor.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次执行上面的任务，结果如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/cTzRbV"><img src="https://z3.ax1x.com/2021/04/20/cTzRbV.jpg" alt="cTzRbV.jpg"></a></p>
<p>任务1，指定自定义线程池，则有该线程池执行任务，其余未指定线程池，则使用自定义的全局线程池执行任务。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>使用过线程池执行任务的伙伴应该会知道，线程提交任务分为execute()方式和submit()方式。</p>
<ul>
<li>对于异步submit提交任务时，使用Future.get()方法获取返回结果时，主线程阻塞并可以处理线程池中的异常。</li>
<li>对于execute()方式提交任务，当异步任务返回类型为 void，异常不会传播到调用线程，故需要通过实现 AsyncUncaughtExceptionHandler接口创建自定义异常处理。</li>
</ul>
<p>故在上面配置全局线程池的基础上，处理异常。从源码中可以得出AsyncConfigurerSupport提供了两个方法，其中getAsyncExecutor()是定义线程池的，getAsyncUncaughtExceptionHandler()是用于处理异常的。</p>
<p><strong>处理异常源码实现如下：</strong></p>
<p>自定义异常处理实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAsyncExceptionHandler</span> <span class="keyword">implements</span> <span class="title">AsyncUncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUncaughtException</span><span class="params">(Throwable e, Method method, Object... args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//处理异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>定义全局线程池重写getAsyncUncaughtExceptionHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CustomAsyncExceptionHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://yeqiu001.github.io/2021/04/19/SpringBoot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/" data-id="cknwys56p0006n2eu77r37341" data-title="SpringBoot定时任务和异步线程池" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ScheduledTask/" rel="tag">ScheduledTask</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Springboot/" rel="tag">Springboot</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-subtree项目使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/subtree%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:59:37.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/git/">git</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/subtree%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/">Git subtree实现总项目与子项目间双向同步</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yeqiu001.github.io/2021/04/15/subtree%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/" data-id="cknwys56u000cn2eu75fk3da6" data-title="Git subtree实现总项目与子项目间双向同步" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/subtree/" rel="tag">subtree</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Gson转换int变为Double问题解决" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/09/Gson%E8%BD%AC%E6%8D%A2int%E5%8F%98%E4%B8%BADouble%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" class="article-date">
  <time class="dt-published" datetime="2021-04-09T07:39:33.000Z" itemprop="datePublished">2021-04-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/09/Gson%E8%BD%AC%E6%8D%A2int%E5%8F%98%E4%B8%BADouble%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/">Gson转换int变为Double问题解决</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、原因"><a href="#一、原因" class="headerlink" title="一、原因"></a>一、原因</h2><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>目前网络上的资料中有两种解决这个问题的办法。</p>
<p>第一种：修改源码。</p>
<p>第二种：添加指定类型的自定义解密工具。</p>
<p>所有能找到的资料中，都对第一种进行了忽略，认为修改源码改动太大，转而使用了第二种方式。</p>
<p>不论是注册Map的解析器，还是使用自定义的Bean对象，本质都是指定类型解析，也就是第二种，完全无法解决以下问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gson.fromJson(s,<span class="keyword">new</span> TypeToken&lt;List&lt;Map&lt;String,Object&gt;&gt;&gt;()&#123;&#125;.getType());</span><br></pre></td></tr></table></figure>

<p>在这段代码中，你可以测试网络中找到的其他解决方式，你会发现所有设置都失效了。</p>
<p>原因是，当你使用 Class 对象作为解析类型时，Gson 会转入你自定义的解析器，而使用 TypeToken 时，Gson 无法将传入的参数与绑定的 TypeToken 对应，最终使用默认解析器。</p>
<h3 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h3><p>接下来我们简述下反序列化的过程，Gson根据待解析的类型定位到具体的TypeAdaptor<T>类，其接口的主要方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">=</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.google.gson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.internal.bind.JsonTreeWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.internal.bind.JsonTreeReader;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.stream.JsonReader;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.stream.JsonToken;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.stream.JsonWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeAdapter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TypeAdapter&lt;T&gt; <span class="title">nullSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TypeAdapter&lt;T&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(JsonWriter out, T value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">          out.nullValue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          TypeAdapter.<span class="keyword">this</span>.write(out, value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> T <span class="title">read</span><span class="params">(JsonReader reader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reader.peek() == JsonToken.NULL) &#123;</span><br><span class="line">          reader.nextNull();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TypeAdapter.<span class="keyword">this</span>.read(reader);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toJson</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    StringWriter stringWriter = <span class="keyword">new</span> StringWriter();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      toJson(stringWriter, value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e); <span class="comment">// No I/O writing to a StringWriter.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringWriter.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> JsonElement <span class="title">toJsonTree</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      JsonTreeWriter jsonWriter = <span class="keyword">new</span> JsonTreeWriter();</span><br><span class="line">      write(jsonWriter, value);</span><br><span class="line">      <span class="keyword">return</span> jsonWriter.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JsonIOException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">read</span><span class="params">(JsonReader in)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">fromJson</span><span class="params">(Reader in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonReader reader = <span class="keyword">new</span> JsonReader(in);</span><br><span class="line">    <span class="keyword">return</span> read(reader);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">fromJson</span><span class="params">(String json)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fromJson(<span class="keyword">new</span> StringReader(json));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">fromJsonTree</span><span class="params">(JsonElement jsonTree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      JsonReader jsonReader = <span class="keyword">new</span> JsonTreeReader(jsonTree);</span><br><span class="line">      <span class="keyword">return</span> read(jsonReader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JsonIOException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过read方法从JsonReader中读取相应的数据组装成最终的对象，由于<strong>Data</strong>类中的extend字段的声明类型是Object，最终Gson会定位到内置的ObjectTypeAdaptor类，我们来分析一下该类的逻辑过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google.gson.internal.bind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.TypeAdapter;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.TypeAdapterFactory;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.internal.LinkedTreeMap;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.reflect.TypeToken;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.stream.JsonReader;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.stream.JsonToken;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.stream.JsonWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTypeAdapter</span> <span class="keyword">extends</span> <span class="title">TypeAdapter</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TypeAdapterFactory FACTORY = <span class="keyword">new</span> TypeAdapterFactory() &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> &lt;T&gt; <span class="function">TypeAdapter&lt;T&gt; <span class="title">create</span><span class="params">(Gson gson, TypeToken&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (type.getRawType() == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> (TypeAdapter&lt;T&gt;) <span class="keyword">new</span> ObjectTypeAdapter(gson);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line"></span><br><span class="line">  ObjectTypeAdapter(Gson gson) &#123;</span><br><span class="line">    <span class="keyword">this</span>.gson = gson;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">(JsonReader in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonToken token = in.peek();</span><br><span class="line">    <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">    <span class="keyword">case</span> BEGIN_ARRAY:</span><br><span class="line">      List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">      in.beginArray();</span><br><span class="line">      <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">        list.add(read(in));</span><br><span class="line">      &#125;</span><br><span class="line">      in.endArray();</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BEGIN_OBJECT:</span><br><span class="line">      Map&lt;String, Object&gt; map = <span class="keyword">new</span> LinkedTreeMap&lt;String, Object&gt;();</span><br><span class="line">      in.beginObject();</span><br><span class="line">      <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">        map.put(in.nextName(), read(in));</span><br><span class="line">      &#125;</span><br><span class="line">      in.endObject();</span><br><span class="line">      <span class="keyword">return</span> map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STRING:</span><br><span class="line">      <span class="keyword">return</span> in.nextString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NUMBER:</span><br><span class="line">      <span class="keyword">return</span> in.nextDouble();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BOOLEAN:</span><br><span class="line">      <span class="keyword">return</span> in.nextBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NULL:</span><br><span class="line">      in.nextNull();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(JsonWriter out, Object value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      out.nullValue();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TypeAdapter&lt;Object&gt; typeAdapter = (TypeAdapter&lt;Object&gt;) gson.getAdapter(value.getClass());</span><br><span class="line">    <span class="keyword">if</span> (typeAdapter <span class="keyword">instanceof</span> ObjectTypeAdapter) &#123;</span><br><span class="line">      out.beginObject();</span><br><span class="line">      out.endObject();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    typeAdapter.write(out, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到该逻辑过程我们看到，如果Json对应的是Object类型，最终会解析为Map&lt;String, Object&gt;类型；其中Object类型跟Json中具体的值有关，比如双引号的””值翻译为STRING。我们可以看下数值类型（NUMBER）全部转换为了Double类型，所以就有了我们之前的问题，整型数据被翻译为了Double类型，比如30变为了30.0。看到这，大家是不是也在想应该细分下NUMBER数值类型，按照整型和浮点型分开处理，我们看下JsonToken是否有更细分的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google.gson.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">JsonToken</span> </span>&#123;</span><br><span class="line">  BEGIN_ARRAY,</span><br><span class="line"></span><br><span class="line">  END_ARRAY,</span><br><span class="line"></span><br><span class="line">  BEGIN_OBJECT,</span><br><span class="line"></span><br><span class="line">  END_OBJECT,</span><br><span class="line"></span><br><span class="line">  NAME,</span><br><span class="line"></span><br><span class="line">  STRING,</span><br><span class="line"></span><br><span class="line">  NUMBER,</span><br><span class="line"></span><br><span class="line">  BOOLEAN,</span><br><span class="line"></span><br><span class="line">  NULL,</span><br><span class="line"></span><br><span class="line">  END_DOCUMENT</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们发现这个枚举类的number类型定义比较宽泛，没有对数字类型进行细分，此时再看JsonReader.peek</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JsonToken <span class="title">peek</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = peeked;</span><br><span class="line">    <span class="keyword">if</span> (p == PEEKED_NONE) &#123;</span><br><span class="line">      p = doPeek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (p) &#123;</span><br><span class="line">    <span class="keyword">case</span> PEEKED_BEGIN_OBJECT:</span><br><span class="line">      <span class="keyword">return</span> JsonToken.BEGIN_OBJECT;</span><br><span class="line">    <span class="keyword">case</span> PEEKED_END_OBJECT:</span><br><span class="line">      <span class="keyword">return</span> JsonToken.END_OBJECT;</span><br><span class="line">    <span class="keyword">case</span> PEEKED_BEGIN_ARRAY:</span><br><span class="line">      <span class="keyword">return</span> JsonToken.BEGIN_ARRAY;</span><br><span class="line">    <span class="keyword">case</span> PEEKED_END_ARRAY:</span><br><span class="line">      <span class="keyword">return</span> JsonToken.END_ARRAY;</span><br><span class="line">    <span class="keyword">case</span> PEEKED_SINGLE_QUOTED_NAME:</span><br><span class="line">    <span class="keyword">case</span> PEEKED_DOUBLE_QUOTED_NAME:</span><br><span class="line">    <span class="keyword">case</span> PEEKED_UNQUOTED_NAME:</span><br><span class="line">      <span class="keyword">return</span> JsonToken.NAME;</span><br><span class="line">    <span class="keyword">case</span> PEEKED_TRUE:</span><br><span class="line">    <span class="keyword">case</span> PEEKED_FALSE:</span><br><span class="line">      <span class="keyword">return</span> JsonToken.BOOLEAN;</span><br><span class="line">    <span class="keyword">case</span> PEEKED_NULL:</span><br><span class="line">      <span class="keyword">return</span> JsonToken.NULL;</span><br><span class="line">    <span class="keyword">case</span> PEEKED_SINGLE_QUOTED:</span><br><span class="line">    <span class="keyword">case</span> PEEKED_DOUBLE_QUOTED:</span><br><span class="line">    <span class="keyword">case</span> PEEKED_UNQUOTED:</span><br><span class="line">    <span class="keyword">case</span> PEEKED_BUFFERED:</span><br><span class="line">      <span class="keyword">return</span> JsonToken.STRING;</span><br><span class="line">    <span class="keyword">case</span> PEEKED_LONG:</span><br><span class="line">    <span class="keyword">case</span> PEEKED_NUMBER:</span><br><span class="line">      <span class="keyword">return</span> JsonToken.NUMBER;</span><br><span class="line">    <span class="keyword">case</span> PEEKED_EOF:</span><br><span class="line">      <span class="keyword">return</span> JsonToken.END_DOCUMENT;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其实在JsonReader的读取过程中是有细分整型和浮点型，可以对外转换后不再区分数值类型了，一种改法是直接修改源码，在JsonToken多定义定义一个整型Long，然后在读取的过程中细分下类型，修改ObjectTypeAdaptor的方法后大概如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">(JsonReader in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonToken token = in.peek();</span><br><span class="line">    <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">        ..........................</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> LONG:</span><br><span class="line">        <span class="keyword">return</span> in.nextLong();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> NUMBER:</span><br><span class="line">            <span class="keyword">return</span> in.nextDouble();</span><br><span class="line"></span><br><span class="line">        ..........................</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是如果我们需要重写TypeAdapter的read()方法</p>
<p>首先我们先创建一个类去继承TypeAdapter，然后重写Read方法，代码如下：</p>
<blockquote>
<p>ObjectTypeAdapter 在创建的 Gson 对象中是不存在的，其使用了内部的工厂对象（FACTORY）动态创建.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TypeAdapterFactory FACTORY = <span class="keyword">new</span> TypeAdapterFactory() &#123;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> &lt;T&gt; <span class="function">TypeAdapter&lt;T&gt; <span class="title">create</span><span class="params">(Gson gson, TypeToken&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.getRawType() == Object.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> (TypeAdapter&lt;T&gt;) <span class="keyword">new</span> ObjectTypeAdapter(gson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而 FACTORY 会在 Gson 的构造函数中加入 factories 对象中。</p>
<pre><code>List&lt;TypeAdapterFactory&gt; factories = new ArrayList&lt;TypeAdapterFactory&gt;();

// built-in type adapters that cannot be overridden
factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);
factories.add(ObjectTypeAdapter.FACTORY);

// the excluder must precede all adapters that handle user-defined types
factories.add(excluder);
</code></pre>
<p>最终，factories 对象通过 Collections 的方法变为不可变列表后保存为成功变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type adapters for composite and user-defined types</span></span><br><span class="line"> factories.add(<span class="keyword">new</span> CollectionTypeAdapterFactory(constructorConstructor));</span><br><span class="line"> factories.add(<span class="keyword">new</span> MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));</span><br><span class="line"> <span class="keyword">this</span>.jsonAdapterFactory = <span class="keyword">new</span> JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);</span><br><span class="line"> factories.add(jsonAdapterFactory);</span><br><span class="line"> factories.add(TypeAdapters.ENUM_FACTORY);</span><br><span class="line"> factories.add(<span class="keyword">new</span> ReflectiveTypeAdapterFactory(</span><br><span class="line">     constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.factories = Collections.unmodifiableList(factories);</span><br></pre></td></tr></table></figure>

<p>找来找去，发现，我们只需要把 Gson 实例中的 factories 对象内部的工厂对象取代即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sedwt.tau.common.adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.TypeAdapter;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.TypeAdapterFactory;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.internal.LinkedTreeMap;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.internal.bind.ObjectTypeAdapter;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.reflect.TypeToken;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.stream.JsonReader;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.stream.JsonToken;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.stream.JsonWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonTypeAdapter</span> <span class="keyword">extends</span> <span class="title">TypeAdapter</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TypeAdapterFactory FACTORY = <span class="keyword">new</span> TypeAdapterFactory() &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">TypeAdapter&lt;T&gt; <span class="title">create</span><span class="params">(Gson gson, TypeToken&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (type.getRawType() == Object.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> (TypeAdapter&lt;T&gt;)<span class="keyword">new</span> GsonTypeAdapter(gson);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GsonTypeAdapter</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gson = gson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">(JsonReader in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JsonToken token = in.peek();</span><br><span class="line">        <span class="comment">// 判断字符串的实际类型</span></span><br><span class="line">        <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">            <span class="keyword">case</span> BEGIN_ARRAY:</span><br><span class="line">                List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                in.beginArray();</span><br><span class="line">                <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">                    list.add(read(in));</span><br><span class="line">                &#125;</span><br><span class="line">                in.endArray();</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> BEGIN_OBJECT:</span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> LinkedTreeMap&lt;&gt;();</span><br><span class="line">                in.beginObject();</span><br><span class="line">                <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">                    map.put(in.nextName(), read(in));</span><br><span class="line">                &#125;</span><br><span class="line">                in.endObject();</span><br><span class="line">                <span class="keyword">return</span> map;</span><br><span class="line">            <span class="keyword">case</span> STRING:</span><br><span class="line">                <span class="keyword">return</span> in.nextString();</span><br><span class="line">            <span class="keyword">case</span> NUMBER:</span><br><span class="line">                String s = in.nextString();</span><br><span class="line">                <span class="keyword">if</span> (s.contains(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Double.valueOf(s);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Integer.valueOf(s);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Long.valueOf(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> BOOLEAN:</span><br><span class="line">                <span class="keyword">return</span> in.nextBoolean();</span><br><span class="line">            <span class="keyword">case</span> NULL:</span><br><span class="line">                in.nextNull();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(JsonWriter out, Object value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            out.nullValue();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// noinspection unchecked</span></span><br><span class="line">        TypeAdapter&lt;Object&gt; typeAdapter = (TypeAdapter&lt;Object&gt;)gson.getAdapter(value.getClass());</span><br><span class="line">        <span class="keyword">if</span> (typeAdapter <span class="keyword">instanceof</span> ObjectTypeAdapter) &#123;</span><br><span class="line">            out.beginObject();</span><br><span class="line">            out.endObject();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        typeAdapter.write(out, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实改动部分只有对 NUMBER 分支的细化，将原始数据是否包含小数点来作为其是否为整数与小数的依据。 我认为原始数据中字面值为 1.0 的数是小数，而字面值为 1 的数为整数。你也可以有自己的实现方式。</p>
<p>使用自定义工厂方法取代 Gson 实例中的工厂方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Gson <span class="title">getGson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Gson gson = <span class="keyword">new</span> GsonBuilder().create();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field factories = Gson.class.getDeclaredField(<span class="string">&quot;factories&quot;</span>);</span><br><span class="line">        factories.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object o = factories.get(gson);</span><br><span class="line">        Class&lt;?&gt;[] declaredClasses = Collections.class.getDeclaredClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class c : declaredClasses) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;java.util.Collections$UnmodifiableList&quot;</span>.equals(c.getName())) &#123;</span><br><span class="line">                Field listField = c.getDeclaredField(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">                listField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                List&lt;TypeAdapterFactory&gt; list = (List&lt;TypeAdapterFactory&gt;) listField.get(o);</span><br><span class="line">                <span class="keyword">int</span> i = list.indexOf(ObjectTypeAdapter.FACTORY);</span><br><span class="line">                list.set(i, MapTypeAdapter.FACTORY);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，首先获得 gson 实例的 factories 属性，将属性设置为 public 访问权限，然后获得其属性 o。</p>
<p>因为在 gson 的创建过程中，factories 通过 Collections 的方法变为了不可修改对象，所以我们需要将其真实属性获得才能进行修改。</p>
<p>通过 Collections 的字节码对象获得其声明的所有内部类，遍历内部类获得 UnmodifiableList 类的字节码对象，最后获得其进行包装之前的真实列表数据 listField，并设置其访问权限为 public。</p>
<p>最终获得了真实的 factories 列表 list。</p>
<p>最后一步，得到 ObjectTypeAdapter.FACTORY 在列表中的位置，并用自定义的工厂对象取代之。需要注意的是，必须要将工厂对象同位置替换，因为解析优先级是和列表中的位置有关的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yeqiu001.github.io/2021/04/09/Gson%E8%BD%AC%E6%8D%A2int%E5%8F%98%E4%B8%BADouble%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" data-id="cknwys56h0001n2eu3xxqco4a" data-title="Gson转换int变为Double问题解决" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Gson/" rel="tag">Gson</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Hystrix容错保护原理及配置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T06:50:04.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringCloud/">SpringCloud</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/">SpringCloud组件：Hystrix容错保护原理及配置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文摘自：<a href="cnblogs.com/jing99/p/11625306.html">kosamino</a></p>
</blockquote>
<center><h3><b>1.什么是灾难性雪崩效应？</b></h3></center>

<p>&emsp;&emsp;如下图的过程所示，灾难性雪崩形成原因就大致如此：</p>
<img src="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/Hystrix1.jpg" class="">

<p>&emsp;&emsp;造成灾难性雪崩效应的原因，可以简单归结为下述三种：</p>
<ul>
<li>服务提供者不可用。如：硬件故障、程序BUG、缓存击穿、并发请求量过大等。</li>
<li>重试加大流量。如：用户重试、代码重试逻辑等。</li>
<li>服务调用者不可用。如：同步请求阻塞造成的资源耗尽等。</li>
</ul>
<p>&emsp;&emsp;雪崩效应最终的结果就是：服务链条中的某一个服务不可用，导致一系列的服务不可用，最终造成服务逻辑崩溃。这种问题造成的后果，往往是无法预料的。</p>
<center><h3><b>2 如何解决灾难性雪崩效应？</b></h3></center>

<p>&emsp;&emsp;解决灾难性雪崩效应的方式通常有：降级、隔离、熔断、请求缓存、请求合并。</p>
<p>&emsp;&emsp;在Spring cloud中处理服务雪崩效应，都需要依赖hystrix组件。在pom文件中都需要引入下述依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通常来说，开发的时候，使用ribbon处理服务灾难雪崩效应（因此章节2示例均采用Ribbon，章节3是Feign实现方式详解），开发的成本低。维护成本高。使用feign技术处理服务灾难雪崩效应，开发的成本较高，维护成本低。</p>
<h4 id="2-1-降级"><a href="#2-1-降级" class="headerlink" title="2.1 降级"></a>2.1 降级</h4><p>&emsp;&emsp;降级是指，当请求超时、资源不足等情况发生时进行服务降级处理，不调用真实服务逻辑，而是使用快速失败（fallback）方式直接返回一个托底数据，保证服务链条的完整，避免服务雪崩。</p>
<p>&emsp;&emsp;解决服务雪崩效应，都是避免application client请求application service时，出现服务调用错误或网络问题。处理手法都是在application client中实现。我们需要在application client相关工程中导入hystrix依赖信息。</p>
<p>&emsp;&emsp;并在对应的启动类上增加新的注解@EnableCircuitBreaker，这个注解是用于开启hystrix熔断器的，简言之，就是让代码中的hystrix相关注解生效。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hystrix依赖， 处理服务灾难雪崩效应的。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;启动器代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableCircuitBreaker</span> - 开启断路器。就是开启hystrix服务容错能力。</span></span><br><span class="line"><span class="comment"> * 当应用启用Hystrix服务容错的时候，必须增加的一个注解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixApplicationClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SpringApplication.run(HystrixApplicationClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在调用application service相关代码中，增加新的方法注解@HystrixCommand，代表当前方法启用Hystrix处理服务雪崩效应。</p>
<p>&emsp;&emsp;@HystrixCommand注解中的属性：fallbackMethod - 代表当调用的application service出现问题时，调用哪个fallback快速失败处理方法返回托底数据。</p>
<p>&emsp;&emsp;实现类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务降级处理。</span></span><br><span class="line"><span class="comment">     * 当前方法远程调用application service服务的时候，如果service服务出现了任何错误（超时，异常等）</span></span><br><span class="line"><span class="comment">     * 不会将异常抛到客户端，而是使用本地的一个fallback（错误返回）方法来返回一个托底数据。</span></span><br><span class="line"><span class="comment">     * 避免客户端看到错误页面。</span></span><br><span class="line"><span class="comment">     * 使用注解来描述当前方法的服务降级逻辑。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@HystrixCommand</span> - 开启Hystrix命令的注解。代表当前方法如果出现服务调用问题，使用Hystrix逻辑来处理。</span></span><br><span class="line"><span class="comment">     *  重要属性 - fallbackMethod</span></span><br><span class="line"><span class="comment">     *      错误返回方法名。如果当前方法调用服务，远程服务出现问题的时候，调用本地的哪个方法得到托底数据。</span></span><br><span class="line"><span class="comment">     *      Hystrix会调用fallbackMethod指定的方法，获取结果，并返回给客户端。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod=&quot;downgradeFallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; testDowngrade() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testDowngrade method : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        ServiceInstance si = </span><br><span class="line">                <span class="keyword">this</span>.loadBalancerClient.choose(<span class="string">&quot;eureka-application-service&quot;</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;http://&quot;</span>).append(si.getHost())</span><br><span class="line">            .append(<span class="string">&quot;:&quot;</span>).append(si.getPort()).append(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;request application service URL : &quot;</span> + sb.toString());</span><br><span class="line">        RestTemplate rt = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; type = </span><br><span class="line">                <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        ResponseEntity&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; response = </span><br><span class="line">                rt.exchange(sb.toString(), HttpMethod.GET, <span class="keyword">null</span>, type);</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; result = response.getBody();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fallback方法。本地定义的。用来处理远程服务调用错误时，返回的基础数据。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Map&lt;String, Object&gt;&gt; downgradeFallback()&#123;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">&quot;id&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        data.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;downgrade fallback datas&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;age&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        result.add(data);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-缓存"><a href="#2-2-缓存" class="headerlink" title="2.2 缓存"></a>2.2 缓存</h4><p>&emsp;&emsp;缓存是指请求缓存。通常意义上说，就是将同样的GET请求结果缓存起来，使用缓存机制（如redis、mongodb）提升请求响应效率。</p>
<p>&emsp;&emsp;使用请求缓存时，需要注意非幂等性操作对缓存数据的影响。</p>
<p>&emsp;&emsp;请求缓存是依托某一缓存服务来实现的。在案例中使用redis作为缓存服务器，那么可以使用spring-data-redis来实现redis的访问操作。需要在application client相关工程中导入下述依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hystrix依赖， 处理服务灾难雪崩效应的。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-- spring-data-redis spring cloud中集成的spring-data相关启动器。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在Spring Cloud应用中，启用spring对cache的支持，需要在启动类中增加注解@EnableCaching，此注解代表当前应用开启spring对cache的支持。简言之就是使spring-data-redis相关的注解生效，如：@CacheConfig、@Cacheable、@CacheEvict等。</p>
<p>&emsp;&emsp;启动器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableCircuitBreaker</span> - 开启断路器。就是开启hystrix服务容错能力。</span></span><br><span class="line"><span class="comment"> * 当应用启用Hystrix服务容错的时候，必须增加的一个注解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableCaching</span> - 开启spring cloud对cache的支持。</span></span><br><span class="line"><span class="comment"> * 可以自动的使用请求缓存，访问redis等cache服务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixApplicationClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixApplicationClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;spring cloud会检查每个幂等性请求，如果请求完全相同（路径、参数等完全一致），则首先访问缓存redis，查看缓存数据，如果缓存中有数据，则不调用远程服务application service。如果缓存中没有数据，则调用远程服务，并将结果缓存到redis中，供后续请求使用。</p>
<p>&emsp;&emsp;如果请求是一个非幂等性操作，则会根据方法的注解来动态管理redis中的缓存数据，避免数据不一致。</p>
<blockquote>
<p>注意：使用请求缓存会导致很多的隐患，如：缓存管理不当导致的数据不同步、问题排查困难等。在商业项目中，解决服务雪崩效应不推荐使用请求缓存。</p>
</blockquote>
<p>&emsp;&emsp;实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在类上，增加<span class="doctag">@CacheConfig</span>注解，用来描述当前类型可能使用cache缓存。</span></span><br><span class="line"><span class="comment"> * 如果使用缓存，则缓存数据的key的前缀是cacheNames。</span></span><br><span class="line"><span class="comment"> * cacheNames是用来定义一个缓存集的前缀命名的，相当于分组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames=&#123;&quot;test.hystrix.cache&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求缓存处理方法。</span></span><br><span class="line"><span class="comment">     * 使用注解<span class="doctag">@Cacheable</span>描述方法。配合启动器中的相关注解，实现一个请求缓存逻辑。</span></span><br><span class="line"><span class="comment">     * 将当期方法的返回值缓存到cache中。</span></span><br><span class="line"><span class="comment">     * 属性 value | cacheNames - 代表缓存到cache的数据的key的一部分。</span></span><br><span class="line"><span class="comment">     * 可以使用springEL来获取方法参数数据，定制特性化的缓存key。</span></span><br><span class="line"><span class="comment">     * 只要方法增加了<span class="doctag">@Cacheable</span>注解，每次调用当前方法的时候，spring cloud都会先访问cache获取数据，</span></span><br><span class="line"><span class="comment">     * 如果cache中没有数据，则访问远程服务获取数据。远程服务返回数据，先保存在cache中，再返回给客户端。</span></span><br><span class="line"><span class="comment">     * 如果cache中有数据，则直接返回cache中的数据，不会访问远程服务。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 请求缓存会有缓存数据不一致的可能。</span></span><br><span class="line"><span class="comment">     * 缓存数据过期、失效、脏数据等情况。</span></span><br><span class="line"><span class="comment">     * 一旦使用了请求缓存来处理幂等性请求操作。则在非幂等性请求操作中必须管理缓存。避免缓存数据的错误。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Cacheable(&quot;testCache4Get&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; testCache4Get() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testCache4Get method thread name : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        ServiceInstance si = </span><br><span class="line">                <span class="keyword">this</span>.loadBalancerClient.choose(<span class="string">&quot;eureka-application-service&quot;</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;http://&quot;</span>).append(si.getHost())</span><br><span class="line">            .append(<span class="string">&quot;:&quot;</span>).append(si.getPort()).append(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;request application service URL : &quot;</span> + sb.toString());</span><br><span class="line">        RestTemplate rt = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; type = </span><br><span class="line">                <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        ResponseEntity&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; response = </span><br><span class="line">                rt.exchange(sb.toString(), HttpMethod.GET, <span class="keyword">null</span>, type);</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; result = response.getBody();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非幂等性操作。用于模拟删除逻辑。</span></span><br><span class="line"><span class="comment">     * 一旦非幂等性操作执行，则必须管理缓存。就是释放缓存中的数据。删除缓存数据。</span></span><br><span class="line"><span class="comment">     * 使用注解<span class="doctag">@CacheEvict</span>管理缓存。</span></span><br><span class="line"><span class="comment">     * 通过数据cacheNames | value来删除对应key的缓存。</span></span><br><span class="line"><span class="comment">     * 删除缓存的逻辑，是在当前方法执行结束后。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CacheEvict(&quot;testCache4Get&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; testCache4Del() &#123;</span><br><span class="line">        ServiceInstance si = </span><br><span class="line">                <span class="keyword">this</span>.loadBalancerClient.choose(<span class="string">&quot;eureka-application-service&quot;</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;http://&quot;</span>).append(si.getHost())</span><br><span class="line">            .append(<span class="string">&quot;:&quot;</span>).append(si.getPort()).append(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;request application service URL : &quot;</span> + sb.toString());</span><br><span class="line">        RestTemplate rt = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; type = </span><br><span class="line">                <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        ResponseEntity&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; response = </span><br><span class="line">                rt.exchange(sb.toString(), HttpMethod.GET, <span class="keyword">null</span>, type);</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; result = response.getBody();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-请求合并"><a href="#2-3-请求合并" class="headerlink" title="2.3 请求合并"></a>2.3 请求合并</h4><p>&emsp;&emsp;请求合并是指，在一定时间内，收集一定量的同类型请求，合并请求需求后，一次性访问服务提供者，得到批量结果。这种方式可以减少服务消费者和服务提供者之间的通讯次数，提升应用执行效率。</p>
<p>&emsp;&emsp;未使用请求合并：</p>
<img src="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/Hystrix2.jpg" class="">

<p>&emsp;&emsp;使用请求合并：</p>
<img src="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/Hystrix3.jpg" class="">

<p><strong>什么情况下使用请求合并：</strong></p>
<p>&emsp;&emsp;在微服务架构中，我们将一个项目拆分成很多个独立的模块，这些独立的模块通过远程调用来互相配合工作，但是，在高并发情况下，通信次数的增加会导致总的通信时间增加，同时，线程池的资源也是有限的，高并发环境会导致有大量的线程处于等待状态，进而导致响应延迟，为了解决这些问题，我们需要来了解Hystrix的请求合并。</p>
<blockquote>
<p>通常来说，服务链条超出4个，不推荐使用请求合并。因为请求合并有等待时间。</p>
</blockquote>
<p><strong>请求合并的缺点：</strong></p>
<p>&emsp;&emsp;设置请求合并之后，本来一个请求可能5ms就搞定了，但是现在必须再等10ms看看还有没有其他的请求一起的，这样一个请求的耗时就从5ms增加到15ms了，不过，如果我们要发起的命令本身就是一个高延迟的命令，那么这个时候就可以使用请求合并了，因为这个时候时间窗的时间消耗就显得微不足道了，另外高并发也是请求合并的一个非常重要的场景。</p>
<p>&emsp;&emsp;引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hystrix依赖， 处理服务灾难雪崩效应的。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;启动器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableCircuitBreaker</span> - 开启断路器。就是开启hystrix服务容错能力。</span></span><br><span class="line"><span class="comment"> * 当应用启用Hystrix服务容错的时候，必须增加的一个注解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixApplicationClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixApplicationClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用注解@HystrixCollapser来描述需要合并请求的方法，并提供合并方法使用注解@HystrixCommand来描述。当合并条件（@HystrixCollapser）满足时，会触发合并方法（@HystrixCommand）来调用远程服务并得到结果。</p>
<p>&emsp;&emsp;@HystrixCollapser注解介绍：此注解描述的方法，返回值类型必须是java.util.concurrent.Future类型的。代表方法为异步方法。</p>
<p><strong>@HystrixCollapser注解的属性：</strong></p>
<ul>
<li>batchMethod - 请求合并方法名。</li>
<li>scope - 请求合并方式。可选值有REQUEST和GLOBAL。REQUEST代表在一个request请求生命周期内的多次远程服务调用请求需要合并处理，此为默认值。GLOBAL代表所有request线程内的多次远程服务调用请求需要合并处理。</li>
<li>timerDelayInMilliseconds - 多少时间间隔内的请求进行合并处理，默认值为10ms。建议设置时间间隔短一些，如果单位时间并发量不大，并没有请求合并的必要。</li>
<li>maxRequestsInBatch - 设置合并请求的最大极值，也就是timerDelayInMilliseconds时间内，最多合并多少个请求。默认值是Integer.MAX_VALUE。</li>
</ul>
<p>&emsp;&emsp;实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要合并请求的方法。</span></span><br><span class="line"><span class="comment">     * 这种方法的返回结果一定是Future类型的。</span></span><br><span class="line"><span class="comment">     * 这种方法的处理逻辑都是异步的。</span></span><br><span class="line"><span class="comment">     * 是application client在一定时间内收集客户端请求，或收集一定量的客户端请求，一次性发给application service。</span></span><br><span class="line"><span class="comment">     * application service返回的结果，application client会进行二次处理，封装为future对象并返回</span></span><br><span class="line"><span class="comment">     * future对象需要通过get方法获取最终的结果。get方法是由控制器调用的。所以控制器调用service的过程是一个异步处理的过程。</span></span><br><span class="line"><span class="comment">     * 合并请求的方法需要使用<span class="doctag">@HystrixCollapser</span>注解描述。</span></span><br><span class="line"><span class="comment">     * batchMethod - 合并请求后，使用的方法是什么。如果当前方法有参数，合并请求后的方法参数是当前方法参数的集合,如 int id &gt;&gt; int[] ids。</span></span><br><span class="line"><span class="comment">     * scope - 合并请求的请求作用域。可选值有global和request。</span></span><br><span class="line"><span class="comment">     *     global代表所有的请求线程都可以等待可合并。 常用，所有浏览器或者请求源（Postman、curl等）调用的请求</span></span><br><span class="line"><span class="comment">     *     request代表一个请求线程中的多次远程服务调用可合并</span></span><br><span class="line"><span class="comment">     * collapserProperties - 细致配置。就是配置合并请求的特性。如等待多久，如可合并请求的数量。</span></span><br><span class="line"><span class="comment">     *     属性的类型是<span class="doctag">@HystrixProperty</span>类型数组，可配置的属性值可以直接通过字符串或常量类定义。</span></span><br><span class="line"><span class="comment">     *     timerDelayInMilliseconds - 等待时长</span></span><br><span class="line"><span class="comment">     *     maxRequestsInBatch - 可合并的请求最大数量。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 方法处理逻辑不需要实现，直接返回null即可。</span></span><br><span class="line"><span class="comment">     * 合并请求一定是可合并的。也就是同类型请求。同URL的请求。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HystrixCollapser(batchMethod = &quot;mergeRequest&quot;, </span></span><br><span class="line"><span class="meta">            scope = com.netflix.hystrix.HystrixCollapser.Scope.GLOBAL,  </span></span><br><span class="line"><span class="meta">            collapserProperties = &#123;  </span></span><br><span class="line"><span class="meta">            // 请求时间间隔在20ms之内的请求会被合并为一个请求,默认为10ms</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;timerDelayInMilliseconds&quot;, value = &quot;20&quot;),</span></span><br><span class="line"><span class="meta">            // 设置触发批处理执行之前，在批处理中允许的最大请求数。</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;maxRequestsInBatch&quot;, value = &quot;200&quot;),  </span></span><br><span class="line"><span class="meta">    &#125;)</span>  </span><br><span class="line">    <span class="keyword">public</span> Future&lt;Map&lt;String, Object&gt;&gt; testMergeRequest(Long id)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量处理方法。就是合并请求后真实调用远程服务的方法。</span></span><br><span class="line"><span class="comment">     * 必须使用<span class="doctag">@HystrixCommand</span>注解描述，代表当前方法是一个Hystrix管理的服务容错方法。</span></span><br><span class="line"><span class="comment">     * 是用于处理请求合并的方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; mergeRequest(List&lt;Long&gt; ids)&#123;</span><br><span class="line">        ServiceInstance si = </span><br><span class="line">                <span class="keyword">this</span>.loadBalancerClient.choose(<span class="string">&quot;eureka-application-service&quot;</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;http://&quot;</span>).append(si.getHost())</span><br><span class="line">            .append(<span class="string">&quot;:&quot;</span>).append(si.getPort()).append(<span class="string">&quot;/testMerge?&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ids.size(); i++)&#123;</span><br><span class="line">            Long id = ids.get(i);</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot;ids=&quot;</span>).append(id);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;request application service URL : &quot;</span> + sb.toString());</span><br><span class="line">        RestTemplate rt = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; type = </span><br><span class="line">                <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        ResponseEntity&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; response = </span><br><span class="line">                rt.exchange(sb.toString(), HttpMethod.GET, <span class="keyword">null</span>, type);</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; result = response.getBody();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-熔断"><a href="#2-4-熔断" class="headerlink" title="2.4 熔断"></a>2.4 熔断</h4><p>&emsp;&emsp;当一定时间内，异常请求比例（请求超时、网络故障、服务异常等）达到阀值时，启动熔断器，熔断器一旦启动，则会停止调用具体服务逻辑，通过fallback快速返回托底数据，保证服务链的完整。</p>
<p>&emsp;&emsp;熔断有自动恢复机制，如：当熔断器启动后，每隔5秒，尝试将新的请求发送给服务提供者，如果服务可正常执行并返回结果，则关闭熔断器，服务恢复。如果仍旧调用失败，则继续返回托底数据，熔断器持续开启状态。</p>
<img src="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/Hystrix4.jpg" class="">

<p>&emsp;&emsp;引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hystrix依赖， 处理服务灾难雪崩效应的。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;启动器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableCircuitBreaker</span> - 开启断路器。就是开启hystrix服务容错能力。</span></span><br><span class="line"><span class="comment"> * 当应用启用Hystrix服务容错的时候，必须增加的一个注解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixApplicationClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixApplicationClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;熔断的实现是在调用远程服务的方法上增加@HystrixCommand注解。当注解配置满足则开启或关闭熔断器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 熔断机制</span></span><br><span class="line"><span class="comment">     * 相当于一个强化的服务降级。 服务降级是只要远程服务出错，立刻返回fallback结果。</span></span><br><span class="line"><span class="comment">     * 熔断是收集一定时间内的错误比例，如果达到一定的错误率。则启动熔断，返回fallback结果。</span></span><br><span class="line"><span class="comment">     * 间隔一定时间会将请求再次发送给application service进行重试。如果重试成功，熔断关闭。</span></span><br><span class="line"><span class="comment">     * 如果重试失败，熔断持续开启，并返回fallback数据。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@HystrixCommand</span> 描述方法。</span></span><br><span class="line"><span class="comment">     *  fallbackMethod - fallback方法名</span></span><br><span class="line"><span class="comment">     *  commandProperties - 具体的熔断标准。类型是HystrixProperty数组。</span></span><br><span class="line"><span class="comment">     *   可以通过字符串或常亮类配置。</span></span><br><span class="line"><span class="comment">     *   CIRCUIT_BREAKER_REQUEST_VOLUME_THRESHOLD - 错误数量。在10毫秒内，出现多少次远程服务调用错误，则开启熔断。</span></span><br><span class="line"><span class="comment">     *       默认20个。10毫秒内有20个错误请求则开启熔断。</span></span><br><span class="line"><span class="comment">     *   CIRCUIT_BREAKER_ERROR_THRESHOLD_PERCENTAGE - 错误比例。在10毫秒内，远程服务调用错误比例达标则开启熔断。</span></span><br><span class="line"><span class="comment">     *   CIRCUIT_BREAKER_SLEEP_WINDOW_IN_MILLISECONDS - 熔断开启后，间隔多少毫秒重试远程服务调用。默认5000毫秒。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;breakerFallback&quot;,</span></span><br><span class="line"><span class="meta">            commandProperties = &#123;</span></span><br><span class="line"><span class="meta">              // 默认20个;10ms内请求数大于20个时就启动熔断器，当请求符合熔断条件时将触发getFallback()。</span></span><br><span class="line"><span class="meta">              @HystrixProperty(name=HystrixPropertiesManager.CIRCUIT_BREAKER_REQUEST_VOLUME_THRESHOLD, </span></span><br><span class="line"><span class="meta">                          value=&quot;10&quot;),</span></span><br><span class="line"><span class="meta">              // 请求错误率大于50%时就熔断，然后for循环发起请求，当请求符合熔断条件时将触发getFallback()。</span></span><br><span class="line"><span class="meta">              @HystrixProperty(name=HystrixPropertiesManager.CIRCUIT_BREAKER_ERROR_THRESHOLD_PERCENTAGE, </span></span><br><span class="line"><span class="meta">                          value=&quot;50&quot;),</span></span><br><span class="line"><span class="meta">              // 默认5秒;熔断多少秒后去尝试请求</span></span><br><span class="line"><span class="meta">              @HystrixProperty(name=HystrixPropertiesManager.CIRCUIT_BREAKER_SLEEP_WINDOW_IN_MILLISECONDS, </span></span><br><span class="line"><span class="meta">                          value=&quot;5000&quot;)&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; testBreaker() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testBreaker method thread name : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        ServiceInstance si = </span><br><span class="line">                <span class="keyword">this</span>.loadBalancerClient.choose(<span class="string">&quot;eureka-application-service&quot;</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;http://&quot;</span>).append(si.getHost())</span><br><span class="line">            .append(<span class="string">&quot;:&quot;</span>).append(si.getPort()).append(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;request application service URL : &quot;</span> + sb.toString());</span><br><span class="line">        RestTemplate rt = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; type = </span><br><span class="line">                <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        ResponseEntity&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; response = </span><br><span class="line">                rt.exchange(sb.toString(), HttpMethod.GET, <span class="keyword">null</span>, type);</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; result = response.getBody();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Map&lt;String, Object&gt;&gt; breakerFallback()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;breakerFallback method thread name : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">&quot;id&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        data.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;breaker fallback datas&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;age&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        result.add(data);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注解属性描述：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CIRCUIT_BREAKER_ENABLED</span><br><span class="line"><span class="string">&quot;circuitBreaker.enabled&quot;</span>;</span><br><span class="line"># 是否开启熔断策略。默认值为true。</span><br><span class="line"></span><br><span class="line">CIRCUIT_BREAKER_REQUEST_VOLUME_THRESHOLD</span><br><span class="line"><span class="string">&quot;circuitBreaker.requestVolumeThreshold&quot;</span>;</span><br><span class="line"># 10ms内，请求并发数超出则触发熔断策略。默认值为20。</span><br><span class="line"></span><br><span class="line">CIRCUIT_BREAKER_SLEEP_WINDOW_IN_MILLISECONDS</span><br><span class="line"><span class="string">&quot;circuitBreaker.sleepWindowInMilliseconds&quot;</span>;</span><br><span class="line"># 当熔断策略开启后，延迟多久尝试再次请求远程服务。默认为5秒。</span><br><span class="line"></span><br><span class="line">CIRCUIT_BREAKER_ERROR_THRESHOLD_PERCENTAGE</span><br><span class="line"><span class="string">&quot;circuitBreaker.errorThresholdPercentage&quot;</span>;</span><br><span class="line"># 10ms内，出现错误的请求百分比达到限制，则触发熔断策略。默认为50%。</span><br><span class="line"></span><br><span class="line">CIRCUIT_BREAKER_FORCE_OPEN</span><br><span class="line"><span class="string">&quot;circuitBreaker.forceOpen&quot;</span>;</span><br><span class="line"># 是否强制开启熔断策略。即所有请求都返回fallback托底数据。默认为false。</span><br><span class="line"></span><br><span class="line">CIRCUIT_BREAKER_FORCE_CLOSED</span><br><span class="line"><span class="string">&quot;circuitBreaker.forceClosed&quot;</span>;</span><br><span class="line"># 是否强制关闭熔断策略。即所有请求一定调用远程服务。默认为false。</span><br></pre></td></tr></table></figure>

<h4 id="2-5-隔离"><a href="#2-5-隔离" class="headerlink" title="2.5 隔离"></a>2.5 隔离</h4><p>&emsp;&emsp;所谓隔离，就是当服务发生问题时，使用技术手段隔离请求，保证服务调用链的完整。隔离分为线程池隔离和信号量隔离两种实现方式。</p>
<h5 id="2-5-1-线程池隔离"><a href="#2-5-1-线程池隔离" class="headerlink" title="2.5.1 线程池隔离"></a>2.5.1 线程池隔离</h5><p>&emsp;&emsp;所谓线程池隔离，就是将并发请求量大的部分服务使用独立的线程池处理，避免因个别服务并发过高导致整体应用宕机。</p>
<p><strong>线程池隔离优点：</strong></p>
<ul>
<li>使用线程池隔离可以完全隔离依赖的服务，请求线程可以快速放回。</li>
<li>当线程池出现问题时，线程池是完全隔离状态的，是独立的，不会影响到其他服务的正常执行。</li>
<li>当崩溃的服务恢复时，线程池可以快速清理并恢复，不需要相对漫长的恢复等待。</li>
<li>独立的线程池也提供了并发处理能力。</li>
</ul>
<p><strong>线程池隔离缺点：</strong></p>
<p>&emsp;&emsp;线程池隔离机制，会导致服务硬件计算开销加大（CPU计算、调度等），每个命令的执行都涉及到排队、调度、上下文切换等，这些命令都是在一个单独的线程上运行的。</p>
<img src="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/Hystrix1.png" class="">

<img src="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/Hystrix2.png" class="">

<img src="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/Hystrix3.png" class="">

<img src="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/Hystrix4.png" class="">

<p>&emsp;&emsp;线程池隔离的实现方式同样是使用@HystrixCommand注解。相关注解配置属性如下：</p>
<ul>
<li><strong>groupKey</strong> - 分组命名，在application client中会为每个application service服务设置一个分组，同一个分组下的服务调用使用同一个线程池。默认值为this.getClass().getSimpleName();</li>
<li><strong>commandKey</strong> - Hystrix中的命令命名，默认为当前方法的方法名。可省略。用于标记当前要触发的远程服务是什么。</li>
<li><strong>threadPoolKey</strong> - 线程池命名。要求一个应用中全局唯一。多个方法使用同一个线程池命名，代表使用同一个线程池。默认值是groupKey数据。</li>
<li><strong>threadPoolProperties</strong> - 用于为线程池设置的参数。其类型为HystrixProperty数组。常用线程池设置参数有：</li>
<li><strong>coreSize</strong> - 线程池最大并发数，建议设置标准为：<code>requests per second at peak when healthy * 99th percentile latency in second + some breathing room</code>。即<code>每秒最大支持请求数*（99%平均响应时间 + 一定量的缓冲时间(99%平均响应时间的10%-20%)）</code>。如：每秒可以处理请求数为1000，99%的响应时间为60ms，自定义提供缓冲时间为<code>60*0.2=12ms</code>，那么结果是 <code>1000*(0.060+0.012) = 72</code>。</li>
<li><strong>maxQueueSize</strong> - BlockingQueue的最大长度，默认值为-1，即不限制。如果设置为正数，等待队列将从同步队列SynchronousQueue转换为阻塞队列LinkedBlockingQueue。</li>
<li><strong>queueSizeRejectionThreshold</strong> - 设置拒绝请求的临界值。默认值为5。此属性是配合阻塞队列使用的，也就是不适用maxQueueSize=-1（为-1的时候此值无效）的情况。是用于设置阻塞队列限制的，如果超出限制，则拒绝请求。此参数的意义就是在服务启动后，可以通过Hystrix的API调用config API动态修改，而不用用重启服务，不常用。</li>
<li><strong>keepAliveTimeMinutes</strong> - 线程存活时间，单位是分钟。默认值为1。</li>
<li><strong>execution.isolation.thread.timeoutInMilliseconds</strong> - 超时时间，默认为1000ms。当请求超时自动中断，返回fallback，避免服务长期阻塞。</li>
<li><strong>execution.isolation.thread.interruptOnTimeout</strong> - 是否开启超时中断。默认为TRUE。和上一个属性配合使用。</li>
</ul>
<p>&emsp;&emsp;引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hystrix依赖， 处理服务灾难雪崩效应的。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;启动器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableCircuitBreaker</span> - 开启断路器。就是开启hystrix服务容错能力。</span></span><br><span class="line"><span class="comment"> * 当应用启用Hystrix服务容错的时候，必须增加的一个注解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixApplicationClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixApplicationClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;实现类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果使用了<span class="doctag">@HystrixCommand</span>注解，则Hystrix自动创建独立的线程池。</span></span><br><span class="line"><span class="comment">     * groupKey和threadPoolKey默认值是当前服务方法所在类型的simpleName</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 所有的fallback方法，都执行在一个HystrixTimer线程池上。</span></span><br><span class="line"><span class="comment">     * 这个线程池是Hystrix提供的一个，专门处理fallback逻辑的线程池。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 线程池隔离实现</span></span><br><span class="line"><span class="comment">     * 线程池隔离，就是为某一些服务，独立划分线程池。让这些服务逻辑在独立的线程池中运行。</span></span><br><span class="line"><span class="comment">     * 不使用tomcat提供的默认线程池。</span></span><br><span class="line"><span class="comment">     * 线程池隔离也有熔断能力。如果线程池不能处理更多的请求的时候，会触发熔断，返回fallback数据。</span></span><br><span class="line"><span class="comment">     * groupKey - 分组名称，就是为服务划分分组。如果不配置，默认使用threadPoolKey作为组名。</span></span><br><span class="line"><span class="comment">     * commandKey - 命令名称，默认值就是当前业务方法的方法名。</span></span><br><span class="line"><span class="comment">     * threadPoolKey - 线程池命名，真实线程池命名的一部分。Hystrix在创建线程池并命名的时候，会提供完整命名。默认使用gourpKey命名</span></span><br><span class="line"><span class="comment">     *  如果多个方法使用的threadPoolKey是同名的，则使用同一个线程池。</span></span><br><span class="line"><span class="comment">     * threadPoolProperties - 为Hystrix创建的线程池做配置。可以使用字符串或HystrixPropertiesManager中的常量指定。</span></span><br><span class="line"><span class="comment">     *  常用线程池配置：</span></span><br><span class="line"><span class="comment">     *      coreSize - 核心线程数。最大并发数。1000*（99%平均响应时间 + 适当的延迟时间）</span></span><br><span class="line"><span class="comment">     *      maxQueueSize - 阻塞队列长度。如果是-1这是同步队列。如果是正数这是LinkedBlockingQueue。如果线程池最大并发数不足，</span></span><br><span class="line"><span class="comment">     *          提供多少的阻塞等待。</span></span><br><span class="line"><span class="comment">     *      keepAliveTimeMinutes - 心跳时间，超时时长。单位是分钟。</span></span><br><span class="line"><span class="comment">     *      queueSizeRejectionThreshold - 拒绝临界值，当最大并发不足的时候，超过多少个阻塞请求，后续请求拒绝。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HystrixCommand(groupKey=&quot;test-thread-quarantine&quot;, </span></span><br><span class="line"><span class="meta">        commandKey = &quot;testThreadQuarantine&quot;,</span></span><br><span class="line"><span class="meta">        threadPoolKey=&quot;test-thread-quarantine&quot;, </span></span><br><span class="line"><span class="meta">        threadPoolProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;coreSize&quot;, value=&quot;30&quot;),</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;maxQueueSize&quot;, value=&quot;100&quot;),</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;keepAliveTimeMinutes&quot;, value=&quot;2&quot;),</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;queueSizeRejectionThreshold&quot;, value=&quot;15&quot;)</span></span><br><span class="line"><span class="meta">        &#125;,</span></span><br><span class="line"><span class="meta">        fallbackMethod = &quot;threadQuarantineFallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; testThreadQuarantine() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testQuarantine method thread name : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        ServiceInstance si = </span><br><span class="line">                <span class="keyword">this</span>.loadBalancerClient.choose(<span class="string">&quot;eureka-application-service&quot;</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;http://&quot;</span>).append(si.getHost())</span><br><span class="line">            .append(<span class="string">&quot;:&quot;</span>).append(si.getPort()).append(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;request application service URL : &quot;</span> + sb.toString());</span><br><span class="line">        RestTemplate rt = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; type = </span><br><span class="line">                <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        ResponseEntity&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; response = </span><br><span class="line">                rt.exchange(sb.toString(), HttpMethod.GET, <span class="keyword">null</span>, type);</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; result = response.getBody();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Map&lt;String, Object&gt;&gt; threadQuarantineFallback()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;threadQuarantineFallback method thread name : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">&quot;id&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        data.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;thread quarantine fallback datas&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;age&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        result.add(data);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;关于线程池：</p>
<ul>
<li>对于所有请求，都交由tomcat容器的线程池处理，是一个以http-nio开头的的线程池；</li>
<li>开启了线程池隔离后，tomcat容器默认的线程池会将请求转交给threadPoolKey定义名称的线程池，处理结束后，由定义的线程池进行返回，无需还回tomcat容器默认的线程池。线程池默认为当前方法名；</li>
<li>所有的fallback都单独由Hystrix创建的一个线程池处理。</li>
</ul>
<h5 id="2-5-2-信号量隔离"><a href="#2-5-2-信号量隔离" class="headerlink" title="2.5.2 信号量隔离"></a>2.5.2 信号量隔离</h5><p>&emsp;&emsp;所谓信号量隔离，就是设置一个并发处理的最大极值。当并发请求数超过极值时，通过fallback返回托底数据，保证服务完整性。</p>
<img src="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/Hystrix5.png" class="">

<p>&emsp;&emsp;信号量隔离同样通过@HystrixCommand注解配置，常用注解属性有：</p>
<ul>
<li><strong>commandProperty</strong> - 配置信号量隔离具体数据。属性类型为HystrixProperty数组，常用配置内容如下：</li>
<li><strong>execution.isolation.strategy</strong> - 设置隔离方式，默认为线程池隔离。可选值只有THREAD和SEMAPHORE。</li>
<li><strong>execution.isolation.semaphore.maxConcurrentRequests</strong> - 最大信号量并发数，默认为10。</li>
</ul>
<p>&emsp;&emsp;依赖注入和启动器同线程池隔离，实现类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量隔离实现</span></span><br><span class="line"><span class="comment">     * 不会使用Hystrix管理的线程池处理请求。使用容器（Tomcat）的线程处理请求逻辑。</span></span><br><span class="line"><span class="comment">     * 不涉及线程切换，资源调度，上下文的转换等，相对效率高。</span></span><br><span class="line"><span class="comment">     * 信号量隔离也会启动熔断机制。如果请求并发数超标，则触发熔断，返回fallback数据。</span></span><br><span class="line"><span class="comment">     * commandProperties - 命令配置，HystrixPropertiesManager中的常量或字符串来配置。</span></span><br><span class="line"><span class="comment">     *     execution.isolation.strategy - 隔离的种类，可选值只有THREAD（线程池隔离）和SEMAPHORE（信号量隔离）。</span></span><br><span class="line"><span class="comment">     *      默认是THREAD线程池隔离。</span></span><br><span class="line"><span class="comment">     *      设置信号量隔离后，线程池相关配置失效。</span></span><br><span class="line"><span class="comment">     *  execution.isolation.semaphore.maxConcurrentRequests - 信号量最大并发数。默认值是10。常见配置500~1000。</span></span><br><span class="line"><span class="comment">     *      如果并发请求超过配置，其他请求进入fallback逻辑。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod=&quot;semaphoreQuarantineFallback&quot;,</span></span><br><span class="line"><span class="meta">            commandProperties=&#123;</span></span><br><span class="line"><span class="meta">              @HystrixProperty(</span></span><br><span class="line"><span class="meta">                      name=HystrixPropertiesManager.EXECUTION_ISOLATION_STRATEGY, </span></span><br><span class="line"><span class="meta">                      value=&quot;SEMAPHORE&quot;), // 信号量隔离</span></span><br><span class="line"><span class="meta">              @HystrixProperty(</span></span><br><span class="line"><span class="meta">                      name=HystrixPropertiesManager.EXECUTION_ISOLATION_SEMAPHORE_MAX_CONCURRENT_REQUESTS, </span></span><br><span class="line"><span class="meta">                      value=&quot;100&quot;) // 信号量最大并发数</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; testSemaphoreQuarantine() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testSemaphoreQuarantine method thread name : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        ServiceInstance si = </span><br><span class="line">                <span class="keyword">this</span>.loadBalancerClient.choose(<span class="string">&quot;eureka-application-service&quot;</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;http://&quot;</span>).append(si.getHost())</span><br><span class="line">            .append(<span class="string">&quot;:&quot;</span>).append(si.getPort()).append(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;request application service URL : &quot;</span> + sb.toString());</span><br><span class="line">        RestTemplate rt = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; type = </span><br><span class="line">                <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        ResponseEntity&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; response = </span><br><span class="line">                rt.exchange(sb.toString(), HttpMethod.GET, <span class="keyword">null</span>, type);</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; result = response.getBody();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Map&lt;String, Object&gt;&gt; semaphoreQuarantineFallback()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;threadQuarantineFallback method thread name : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">&quot;id&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        data.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;thread quarantine fallback datas&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;age&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        result.add(data);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-3线程池隔离和信号量隔离的对比"><a href="#2-5-3线程池隔离和信号量隔离的对比" class="headerlink" title="2.5.3线程池隔离和信号量隔离的对比"></a>2.5.3线程池隔离和信号量隔离的对比</h5><center><b>对比</b></center>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">线程池隔离</th>
<th align="center">信号量隔离</th>
</tr>
</thead>
<tbody><tr>
<td align="center">线程</td>
<td align="center">请求处理线程和调用服务线程不是同一个线程</td>
<td align="center">请求处理线程和调用服务线程是同一个线程</td>
</tr>
<tr>
<td align="center">开销</td>
<td align="center">资源开销大（需要处理线程排队、调度、上下文切换等）</td>
<td align="center">无线程切换，开销小</td>
</tr>
<tr>
<td align="center">异步</td>
<td align="center">支持异步处理</td>
<td align="center">不支持异步处理</td>
</tr>
<tr>
<td align="center">并发支持</td>
<td align="center">支持，由线程池容量限制并发能力</td>
<td align="center">支持，由信号量配置限制并发能力</td>
</tr>
<tr>
<td align="center">传递请求header</td>
<td align="center">切换了线程，不能传递请求header</td>
<td align="center">不切换线程，可以传递header</td>
</tr>
<tr>
<td align="center">超时支持</td>
<td align="center">支持超时处理，当请求超时，自动中断</td>
<td align="center">不支持超时处理，必须等待远程调用结束，再判断是否超时</td>
</tr>
</tbody></table>
<h5 id="2-5-4线程池隔离和信号量隔离的选择"><a href="#2-5-4线程池隔离和信号量隔离的选择" class="headerlink" title="2.5.4线程池隔离和信号量隔离的选择"></a>2.5.4线程池隔离和信号量隔离的选择</h5><ul>
<li>线程池隔离：请求并发大，耗时较长（一般都是计算大，服务链长或访问数据库）时使用线程池隔离。可以尽可能保证外部容器（如Tomcat）线程池可用，不会因为服务调用的原因导致请求阻塞等待。</li>
<li>信号量隔离：请求并发大，耗时短（计算小，服务链段或访问缓存）时使用信号量隔离。因为这类服务的响应快，不会占用外部容器（如Tomcat）线程池太长时间，减少线程的切换，可以避免不必要的开销，提高服务处理效率。</li>
</ul>
<center><h3><b>3 Feign的雪崩处理</b></h3></center>

<p>&emsp;&emsp;在声明式远程服务调用Feign中，实现服务灾难性雪崩效应处理也是通过Hystrix实现的。而feign启动器spring-cloud-starter-feign中是包含Hystrix相关依赖的。</p>
<p>&emsp;&emsp;如果只使用服务降级、熔断功能不需要做独立依赖。如果需要使用Hystrix其他服务容错能力，需要依赖spring-cloud-starter-hystrix资源。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hystrix依赖。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从Dalston版本后，feign默认关闭Hystrix支持。所以必须在全局配置文件中开启feign技术中的Hystrix支持。配置如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">feign.hystrix.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果不使用Hystrix服务容错功能，在application client端，服务接口只需要继承服务标准api接口即可实现远程服务调用。如果使用了Hystrix，则有不同的编写方式。具体如下。</p>
<h4 id="3-1-代码实现-接口实现类方式"><a href="#3-1-代码实现-接口实现类方式" class="headerlink" title="3.1 代码实现 - 接口实现类方式"></a>3.1 代码实现 - 接口实现类方式</h4><p>&emsp;&emsp;定义和服务标准api相同的application client服务接口。并通过@FeignClient注解来描述fallback方法所在类是什么。这个fallback方法所在类就是接口的实现类，实现的方法就是接口中定义方法的fallback方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果在Feign中使用Hystrix，则不能直接继承服务标准接口。</span></span><br><span class="line"><span class="comment"> * 因为继承接口，一般都不会给予实现。会缺少fallback方法。熔断机制链条不完整。</span></span><br><span class="line"><span class="comment"> * 在当前接口中，重复定义服务标准接口中定义的方法。</span></span><br><span class="line"><span class="comment"> * 远程服务调用的时候，是通过<span class="doctag">@FeignClient</span>实现的。</span></span><br><span class="line"><span class="comment"> * 如果远程服务调用失败，则触发fallback注解属性定义的接口实现类中的对应方法，作为fallback方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在默认的Hystrix配置环境中，使用的是服务降级保护机制。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 服务降级，默认的情况下，包含了请求超时。</span></span><br><span class="line"><span class="comment"> * feign声明式远程服务调用，在启动的时候，初始化过程比较慢（通过注释<span class="doctag">@FeignClient</span>描述接口，接口生成动态代理对象，实现服务调用）。比ribbon要慢很多。</span></span><br><span class="line"><span class="comment"> * 很容易在第一次访问的时候，产生超时。导致返回fallback数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(name=&quot;test-feign-application-service&quot;,</span></span><br><span class="line"><span class="meta">        fallback=FirstClientFeignServiceImpl.class</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FirstClientFeignService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/testFeign&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">testFeign</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/get&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">getById</span><span class="params">(<span class="meta">@RequestParam(value=&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/get&quot;, method=RequestMethod.POST)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">getByIdWithPOST</span><span class="params">(<span class="meta">@RequestBody</span> Long id)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/add&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">add</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id, <span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/addWithGET&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">add</span><span class="params">(<span class="meta">@RequestBody</span> FeignTestPOJO pojo)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/addWithPOST&quot;, method=RequestMethod.POST)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">addWithPOST</span><span class="params">(<span class="meta">@RequestBody</span> FeignTestPOJO pojo)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为接口提供实现类，类中的方法实现就是fallback逻辑。实现类需要spring容器管理，使用@Component注解来描述类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现类中的每个方法，都是对应的接口方法的fallback。</span></span><br><span class="line"><span class="comment"> * 一定要提供spring相关注解（<span class="doctag">@Component</span>/<span class="doctag">@Service</span>/<span class="doctag">@Repository</span>等）。</span></span><br><span class="line"><span class="comment"> * 注解是为了让当前类型的对象被spring容器管理。</span></span><br><span class="line"><span class="comment"> * fallback是本地方法。</span></span><br><span class="line"><span class="comment"> * 是接口的实现方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstClientFeignServiceImpl</span> <span class="keyword">implements</span> <span class="title">FirstClientFeignService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">testFeign</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        result.add(<span class="string">&quot;this is testFeign method fallback datas&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">getById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FeignTestPOJO(-<span class="number">1L</span>, <span class="string">&quot;this is getById method fallback datas&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">getByIdWithPOST</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FeignTestPOJO(-<span class="number">1L</span>, <span class="string">&quot;this is getByIdWithPOST method fallback datas&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">add</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FeignTestPOJO(-<span class="number">1L</span>, <span class="string">&quot;this is add(id, name) method fallback datas&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">add</span><span class="params">(FeignTestPOJO pojo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FeignTestPOJO(-<span class="number">1L</span>, <span class="string">&quot;this is add(pojo) method fallback datas&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">addWithPOST</span><span class="params">(FeignTestPOJO pojo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FeignTestPOJO(-<span class="number">1L</span>, <span class="string">&quot;this is addWithPOST method fallback datas&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-相关配置"><a href="#3-2-相关配置" class="headerlink" title="3.2 相关配置"></a>3.2 相关配置</h4><p>&emsp;&emsp;在Feign技术中，一般不使用请求合并，请求缓存等容错机制。常用的机制是隔离，降级和熔断。</p>
<h5 id="3-2-1-Properties全局配置"><a href="#3-2-1-Properties全局配置" class="headerlink" title="3.2.1 Properties全局配置"></a>3.2.1 Properties全局配置</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hystrix.command.default和hystrix.threadpool.default中的default为默认CommandKey，CommandKey默认值为服务方法名。# 在properties配置中配置格式混乱，如果需要为每个方法设置不同的容错规则，建议使用yml文件配置。</span></span><br><span class="line"><span class="comment"># Command Properties</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Execution相关的属性的配置：</span></span><br><span class="line"><span class="comment"># 隔离策略，默认是Thread, 可选Thread｜Semaphore</span></span><br><span class="line"><span class="meta">hystrix.command.default.execution.isolation.strategy</span>=<span class="string">THREAD</span></span><br><span class="line"><span class="comment">#命令执行超时时间，默认1000ms，只在线程池隔离中有效。</span></span><br><span class="line"><span class="meta">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment"># 执行是否启用超时，默认启用true，只在线程池隔离中有效。</span></span><br><span class="line"><span class="meta">hystrix.command.default.execution.timeout.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 发生超时是是否中断，默认true，只在线程池隔离中有效。</span></span><br><span class="line"><span class="meta">hystrix.command.default.execution.isolation.thread.interruptOnTimeout</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 最大并发请求数，默认10，该参数当使用ExecutionIsolationStrategy.SEMAPHORE策略时才有效。如果达到最大并发请求数，请求会被拒绝。# 理论上选择semaphore的原则和选择thread一致，但选用semaphore时每次执行的单元要比较小且执行速度快（ms级别），否则的话应该用thread。# semaphore应该占整个容器（tomcat）的线程池的一小部分。</span></span><br><span class="line"><span class="meta">hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 如果并发数达到该设置值，请求会被拒绝和抛出异常并且fallback不会被调用。默认10。# 只在信号量隔离策略中有效，建议设置大一些，这样并发数达到execution最大请求数时，会直接调用fallback，而并发数达到fallback最大请求数时会被拒绝和抛出异常。</span></span><br><span class="line"><span class="meta">hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># ThreadPool 相关参数</span></span><br><span class="line"><span class="comment"># 并发执行的最大线程数，默认10</span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.coreSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># BlockingQueue的最大队列数，当设为-1，会使用SynchronousQueue，值为正时使用LinkedBlcokingQueue。# 该设置只会在初始化时有效，之后不能修改threadpool的queue size，除非reinitialising thread executor。默认-1。</span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.maxQueueSize</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 即使maxQueueSize没有达到，达到queueSizeRejectionThreshold该值后，请求也会被拒绝。</span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.queueSizeRejectionThreshold</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"># 线程存活时间，单位是分钟。默认值为1。</span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.keepAliveTimeMinutes</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># Fallback相关的属性 # 当执行失败或者请求被拒绝，是否会尝试调用fallback方法 。默认true hystrix.command.default.fallback.enabled=true # Circuit Breaker相关的属性 # 是否开启熔断器。默认true hystrix.command.default.circuitBreaker.enabled=true # 一个rolling window内最小的请求数。如果设为20，那么当一个rolling window的时间内（比如说1个rolling window是10毫秒）收到19个请求# 即使19个请求都失败，也不会触发circuit break。默认20</span></span><br><span class="line"><span class="meta">hystrix.command.default.circuitBreaker.requestVolumeThreshold</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"># 触发短路的时间值，当该值设为5000时，则当触发circuit break后的5000毫秒内都会拒绝远程服务调用，也就是5000毫秒后才会重试远程服务调用。默认5000</span></span><br><span class="line"><span class="meta">hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds</span>=<span class="string">5000</span></span><br><span class="line"><span class="comment"># 错误比率阀值，如果错误率&gt;=该值，circuit会被打开，并短路所有请求触发fallback。默认50</span></span><br><span class="line"><span class="meta">hystrix.command.default.circuitBreaker.errorThresholdPercentage</span>=<span class="string">50</span></span><br><span class="line"><span class="comment"># 强制打开熔断器</span></span><br><span class="line"><span class="meta">hystrix.command.default.circuitBreaker.forceOpen</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 强制关闭熔断器</span></span><br><span class="line"><span class="meta">hystrix.command.default.circuitBreaker.forceClosed</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-YML全局配置"><a href="#3-2-2-YML全局配置" class="headerlink" title="3.2.2 YML全局配置"></a>3.2.2 YML全局配置</h5><p>&emsp;&emsp;YML配置文件，对SpringEL的支持更加优秀。可以通过SpringEL定制化的为每个服务调用配置Hystrix的容错处理方案。对Hystrix的配置粒度相比较Properties的配置方案更加细致。</p>
<p>&emsp;&emsp;在YML中可配置的Hystrix信息，和Properties中配置的内容是一致。</p>
<p>&emsp;&emsp;如果需要对每个服务做定制化配置，建议使用yml配置文件。在语法和格式上更容易管理和维护。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-feign-application-client</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9008</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="comment"># default代表全部服务配置，如果为某个具体服务定制配置，使用：&#x27;服务接口名#方法名(参数类型列表)&#x27;的方式来定义。</span></span><br><span class="line">    <span class="comment"># 如：&#x27;FirstClientFeignService#test(int)&#x27;。如果接口名称在应用中唯一，可以只写simpleName。</span></span><br><span class="line">    <span class="comment"># 如果接口名称在应用中不唯一，需要写fullName（包名.类名）</span></span><br><span class="line">    <span class="string">&quot;FirstClientFeignService#testFeign()&quot;</span><span class="string">:</span></span><br><span class="line">      <span class="attr">fallback:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-代码实现-Factory实现方式"><a href="#3-3-代码实现-Factory实现方式" class="headerlink" title="3.3 代码实现 - Factory实现方式"></a>3.3 代码实现 - Factory实现方式</h4><p>&emsp;&emsp;在服务接口的@FeignClient注解中，不再使用fallback属性，而是定义fallbackFactory属性。这个属性的类型是Class类型的，用于配置fallback代码所处的Factory。</p>
<p>&emsp;&emsp;再定义一个Java类，实现接口FallbackFactory，实现其中的create方法。使用匿名内部类的方式，为服务接口定义一个实现类，定义fallback方法实现。</p>
<p>&emsp;&emsp;本地接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name=&quot;test-feign-application-service&quot;,</span></span><br><span class="line"><span class="meta">        fallbackFactory=FirstClientFeignServiceFallbackFactory.class</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FirstClientFeignService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/testFeign&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">testFeign</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/get&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">getById</span><span class="params">(<span class="meta">@RequestParam(value=&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/get&quot;, method=RequestMethod.POST)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">getByIdWithPOST</span><span class="params">(<span class="meta">@RequestBody</span> Long id)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/add&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">add</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id, <span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/addWithGET&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">add</span><span class="params">(<span class="meta">@RequestBody</span> FeignTestPOJO pojo)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/addWithPOST&quot;, method=RequestMethod.POST)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">addWithPOST</span><span class="params">(<span class="meta">@RequestBody</span> FeignTestPOJO pojo)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;FallbackFactory实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Factory方式实现Feign的Hystrix容错处理。</span></span><br><span class="line"><span class="comment"> * 编写的自定义Factory必须实现接口FallbackFactory。</span></span><br><span class="line"><span class="comment"> * FallbackFactory中的方法是</span></span><br><span class="line"><span class="comment"> *  服务接口的类型 create(Throwable 远程服务调用的错误)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 工厂实现方案和服务接口实现类实现方案的区别：</span></span><br><span class="line"><span class="comment"> *  工厂可以提供自定义的异常信息处理逻辑。因为create方法负责传递远程服务调用的异常对象。</span></span><br><span class="line"><span class="comment"> *  实现类可以快速的开发，但是会丢失远程服务调用的异常信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstClientFeignServiceFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">FirstClientFeignService</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(FirstClientFeignServiceFallbackFactory.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create方法 - 就是工厂的生产产品的方法。</span></span><br><span class="line"><span class="comment">     *  当前工厂生产的产品就是服务接口的Fallback处理对象。 就是服务接口的实现类的对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FirstClientFeignService <span class="title">create</span><span class="params">(<span class="keyword">final</span> Throwable cause)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FirstClientFeignService() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">testFeign</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;testFeign() - &quot;</span>, cause);</span><br><span class="line">                List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                result.add(<span class="string">&quot;this is testFeign method fallback datas&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">getById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> FeignTestPOJO(-<span class="number">1L</span>, <span class="string">&quot;this is getById method fallback datas&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">getByIdWithPOST</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> FeignTestPOJO(-<span class="number">1L</span>, <span class="string">&quot;this is getByIdWithPOST method fallback datas&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">add</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> FeignTestPOJO(-<span class="number">1L</span>, <span class="string">&quot;this is add(id, name) method fallback datas&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">add</span><span class="params">(FeignTestPOJO pojo)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> FeignTestPOJO(-<span class="number">1L</span>, <span class="string">&quot;this is add(pojo) method fallback datas&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FeignTestPOJO <span class="title">addWithPOST</span><span class="params">(FeignTestPOJO pojo)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> FeignTestPOJO(-<span class="number">1L</span>, <span class="string">&quot;this is addWithPOST method fallback datas&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这种实现逻辑的优势是，可以获取远程调用服务的异常信息。为后期异常处理提供参考。</p>
<p>&emsp;&emsp;工厂实现方案和实现类的实现方案，没有效率和逻辑上的优缺点对比。只是在远程服务调用异常的处理上有区别。</p>
<center><h3><b>4 Hystrix Dashboard - 数据监控</b></h3></center>

<p>&emsp;&emsp;Hystrix dashboard是一款针对Hystrix进行实时监控的工具，通过Hystrix Dashboard我们可以在直观地看到各Hystrix Command的请求响应时间, 请求成功率等数据。</p>
<h4 id="4-1-实现单服务单节点数据监控"><a href="#4-1-实现单服务单节点数据监控" class="headerlink" title="4.1 实现单服务单节点数据监控"></a>4.1 实现单服务单节点数据监控</h4><p>&emsp;&emsp;在使用了Hystrix技术的application client工程中增加下述依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在启动器上增加注解@EnableHystrixDashboard、@EnableHystrix。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardApplication.class, args);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;启动工程后，如果触发了Hystrix，则可以通过<a href="http://ip:port/hystrix.stream得到监控数据。这种监控数据的获取都是JSON数据。">http://ip:port/hystrix.stream得到监控数据。这种监控数据的获取都是JSON数据。</a></p>
<p>&emsp;&emsp;且数据量级较大。不易于查看。可以使用Hystrix Dashboard提供的视图界面来观察监控结果。视图界面访问路径为<a href="http://ip:port/hystrix。视图界面中各数据的含义如下：">http://ip:port/hystrix。视图界面中各数据的含义如下：</a></p>
<img src="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/Hystrix6.png" class="">

<blockquote>
<p>建议：监控中心建议使用独立工程来实现。这样更便于维护。</p>
</blockquote>
<h4 id="4-2-使用Turbine实现多服务或集群的数据监控"><a href="#4-2-使用Turbine实现多服务或集群的数据监控" class="headerlink" title="4.2 使用Turbine实现多服务或集群的数据监控"></a>4.2 使用Turbine实现多服务或集群的数据监控</h4><p>&emsp;&emsp;Turbine是聚合服务器发送事件流数据的一个工具，hystrix的监控中，只能监控单个服务或单个节点，实际生产中都为多服务集群，因此可以通过turbine来监控多集群服务。</p>
<p>&emsp;&emsp;Turbine在Hystrix Dashboard中的作用如下：</p>
<img src="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/Hystrix7.png" class="">

<h5 id="4-2-1多服务监控"><a href="#4-2-1多服务监控" class="headerlink" title="4.2.1多服务监控"></a>4.2.1多服务监控</h5><p>&emsp;&emsp;当使用Turbine来监控多服务状态时，需提供一个独立工程来搭建Turbine服务逻辑。并在工程中增加下述依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Dashboard需要的依赖信息。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Turbine需要的依赖信息。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;并在全局配置文件中增加下述配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#配置Eureka中的serviceId列表，标记监控哪些服务，多个服务名用逗号分隔，可以配置监控的服务，必须开启了Hystrix Dashboard。</span></span><br><span class="line"><span class="meta">turbine.appConfig</span>=<span class="string">hystrix-application-client,test-feign-application-client</span></span><br><span class="line"><span class="comment">#指定聚合哪些集群，多个使用&quot;,&quot;分割，default代表默认集群。集群就是服务名称。需要配置clusterNameExpression使用。</span></span><br><span class="line"><span class="meta">turbine.aggregator.clusterConfig</span>=<span class="string">default</span></span><br><span class="line"><span class="comment"># 1. clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称；</span></span><br><span class="line"><span class="comment"># 2. 当clusterNameExpression: default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default；代表所有集群都需要监控</span></span><br><span class="line"><span class="meta">turbine.clusterNameExpression</span>=<span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在应用启动类中，增加注解@EnableTurbine，代表开启Turbine服务，提供多服务集群监控数据收集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableTurbine</span> - 开启Turbine功能。</span></span><br><span class="line"><span class="comment"> *  可以实现收集多个App client的Dashboard监控数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTurbine</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixTurbineApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixTurbineApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;最后再Hystrix Dashboard视图监控服务中，使用<a href="http://ip:port/turbine.stream作为监控数据来源，提供可视化监控界面">http://ip:port/turbine.stream作为监控数据来源，提供可视化监控界面</a></p>
<blockquote>
<p>注意：使用Turbine做多服务监控的时候，要求全局配置文件中配置的服务列表命名在Eureka注册中心中可见。就是先启动Application client再启动Turbine。</p>
</blockquote>
<h5 id="4-2-2服务集群监控"><a href="#4-2-2服务集群监控" class="headerlink" title="4.2.2服务集群监控"></a>4.2.2服务集群监控</h5><p>&emsp;&emsp;在spring cloud中，服务名相同的多服务结点会自动形成集群，并提供服务。在Turbine中，监控服务集群不需要提供任何的特殊配置，因为turbine.appConfig已经配置了要监控的服务名称。集群监控数据会自动收集。</p>
<p>&emsp;&emsp;在Hystrix Dashboard的可视化监控界面中，hosts信息会显示出服务集群中的节点数量。如图所示：</p>
<img src="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/Hystrix5.jpg" class="">

<blockquote>
<p>注意：使用Turbine做服务集群监控的时候，必须先启动application client集群，再启动Turbine。保证Turbine启动的时候，可以在eureka注册中心中发现要监控的服务集群。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yeqiu001.github.io/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/" data-id="cknwys587001tn2eu3bpu2cql" data-title="SpringCloud组件：Hystrix容错保护原理及配置" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hystrix/" rel="tag">Hystrix</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-索引失效" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/02/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/" class="article-date">
  <time class="dt-published" datetime="2021-04-02T03:13:19.000Z" itemprop="datePublished">2021-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Sql/">Sql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/02/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/">索引失效</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文摘自： <a href="blog.csdn.net/bless2015/article/details/84134361">番茄发烧了</a></p>
</blockquote>
<p>&emsp;&emsp;虽然你这列上建了索引，查询条件也是索引列，但最终执行计划没有走它的索引。下面是引起这种问题的几个关键点。</p>
<h4 id="列与列对比"><a href="#列与列对比" class="headerlink" title="列与列对比"></a><strong>列与列对比</strong></h4><p>&emsp;&emsp;某个表中，有两列（id和c_id）都建了单独索引，下面这种查询条件不会走索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span>c_id;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这种情况会被认为还不如走全表扫描。</p>
<h4 id="存在NULL值条件"><a href="#存在NULL值条件" class="headerlink" title="存在NULL值条件"></a><strong>存在NULL值条件</strong></h4><p>&emsp;&emsp;我们在设计数据库表时，应该尽力避免NULL值出现，如果非要不可避免的要出现NULL值，也要给一个DEFAULT值，数值型可以给0、-1之类的， 字符串有时候给空串有问题，就给一个空格或其他。</p>
<p>&emsp;&emsp;如果索引列是可空的，很可能是不会给其建索引的，索引值是少于表的<code>count(*)</code>值的，所以这种情况下，执行计划自然就去扫描全表了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="NOT条件"><a href="#NOT条件" class="headerlink" title="NOT条件"></a><strong>NOT条件</strong></h4><p>&emsp;&emsp;我们知道建立索引时，给每一个索引列建立一个条目，如果查询条件为等值或范围查询时，索引可以根据查询条件去找对应的条目。</p>
<p>&emsp;&emsp;反过来当查询条件为非时，索引定位就困难了，执行计划此时可能更倾向于全表扫描，这类的查询条件有：<code>&lt;&gt;</code>、<code>NOT</code>、<code>in</code>、<code>not exists</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">&lt;&gt;</span><span class="number">500</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> test_02 <span class="keyword">where</span> test_02.id<span class="operator">=</span>test.id);</span><br></pre></td></tr></table></figure>

<h4 id="LIKE通配符"><a href="#LIKE通配符" class="headerlink" title="LIKE通配符"></a><strong>LIKE通配符</strong></h4><p>&emsp;&emsp;当使用模糊搜索时，尽量采用后置的通配符，例如：name||’%’，因为走索引时，其会从前去匹配索引列，这时候是可以找到的，如果采用前匹配，那么查索引就会很麻烦，比如查询所有姓张的人，就可以去搜索’张%’。</p>
<p>&emsp;&emsp;相反如果你查询所有叫‘明’的人，那么只能是%明。这时候索引如何定位呢？前匹配的情况下，执行计划会更倾向于选择全表扫描。后匹配可以走INDEX RANGE SCAN。</p>
<p>&emsp;&emsp;所以业务设计的时候，尽量考虑到模糊搜索的问题，要更多的使用后置通配符。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> name <span class="keyword">like</span> 张<span class="operator">||</span><span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="条件上包括函数"><a href="#条件上包括函数" class="headerlink" title="条件上包括函数"></a><strong>条件上包括函数</strong></h4><p>&emsp;&emsp;查询条件上尽量不要对索引列使用函数，比如下面这个SQL.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="built_in">upper</span>(name)<span class="operator">=</span><span class="string">&#x27;SUNYANG&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样是不会走索引的，因为索引在建立时会和计算后可能不同，无法定位到索引。但如果查询条件不是对索引列进行计算，那么依然可以走索引。比如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> name<span class="operator">=</span><span class="built_in">upper</span>(<span class="string">&#x27;sunyang&#x27;</span>);</span><br><span class="line"><span class="comment">--INDEX RANGE SCAN</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样的函数还有：to_char、to_date、to_number、trunc等。</p>
<h4 id="复合索引前导列区分大"><a href="#复合索引前导列区分大" class="headerlink" title="复合索引前导列区分大"></a><strong>复合索引前导列区分大</strong></h4><p>&emsp;&emsp;当复合索引前导列区分小的时候，我们有INDEX SKIP SCAN，当前导列区分度大，且查后导列的时候，前导列的分裂会非常耗资源，执行计划想，还不如全表扫描来的快，然后就索引失效了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> owner<span class="operator">=</span><span class="string">&#x27;sunyang&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a><strong>数据类型的转换</strong></h4><p>&emsp;&emsp;当查询条件存在隐式转换时，索引会失效。</p>
<p>&emsp;&emsp;比如在数据库里id存的number类型，但是在查询时，却用了下面的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sunyang <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Connect-By-Level"><a href="#Connect-By-Level" class="headerlink" title="Connect By Level"></a><strong>Connect By Level</strong></h4><p>&emsp;&emsp;使用connect by level时，不会走索引。</p>
<h4 id="谓词运算"><a href="#谓词运算" class="headerlink" title="谓词运算"></a><strong>谓词运算</strong></h4><p>&emsp;&emsp;我们在上面说，不能对索引列进行函数运算，这也包括加减乘除的谓词运算，这也会使索引失效。</p>
<p>&emsp;&emsp;建立一个sunyang表，索引为id，看这个SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sunyang <span class="keyword">where</span> id<span class="operator">/</span><span class="number">2</span><span class="operator">=</span>:type_id;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里很明显对索引列id进行了’/2’除二运算，这时候就会索引失效，这种情况应该改写为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sunyang <span class="keyword">where</span> id<span class="operator">=</span>:type_id<span class="operator">*</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;就可以使用索引了。</p>
<h4 id="Vistual-Index"><a href="#Vistual-Index" class="headerlink" title="Vistual Index"></a><strong>Vistual Index</strong></h4><p>&emsp;&emsp;先说明一下，虚拟索引的建立是否有用，需要看具体的执行计划，如果起作用就可以建一个，如果不起作用就算了。普通索引这么建：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_test_id <span class="keyword">on</span> test(id);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;虚拟索引Vistual Index这么建：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_test_id <span class="keyword">on</span> test(id) nosegment;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;做了一个实验，首先创建一个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_1116( </span><br><span class="line">id number, </span><br><span class="line">a number </span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_test_1116_id <span class="keyword">on</span> test_1116(id); </span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_test_1116_a <span class="keyword">on</span> test_1116(a)nosegment; </span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中id为普通索引，a为虚拟索引。</p>
<p>&emsp;&emsp;在表中插入十万条数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> .. <span class="number">100000</span> loop </span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> test_1116 <span class="keyword">values</span> (i,i); </span><br><span class="line"><span class="keyword">end</span> loop; </span><br><span class="line"><span class="keyword">commit</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接着分别去执行下面的SQL看时间，由于在内网机做实验，图贴不出来，数据保证真实性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(id) <span class="keyword">from</span> test_1116;</span><br><span class="line"><span class="comment">--第一次耗时：0.061秒</span></span><br><span class="line"><span class="comment">--第二次耗时：0.016秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(a) <span class="keyword">from</span> test_1116; </span><br><span class="line"><span class="comment">--第一次耗时：0.031秒</span></span><br><span class="line"><span class="comment">--第二次耗时：0.016秒</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;因为在执行过一次后，oracle对结果集缓存了，所以第二次执行耗时不走索引，走内存就都一样了。</p>
<p>&emsp;&emsp;可以看到在这种情况下，虚拟索引比普通索引快了一倍。</p>
<p>&emsp;&emsp;具体虚拟索引的使用细节，这里不再展开讨论。</p>
<h4 id="Invisible-Index"><a href="#Invisible-Index" class="headerlink" title="Invisible Index"></a><strong>Invisible Index</strong></h4><p>&emsp;&emsp;Invisible Index是oracle 11g提供的新功能，对优化器（还接到前面博客里讲到的CBO吗）不可见，MySQL 也有，MySQL 8.0 中的索引可以隐藏了。我感觉这个功能更主要的是测试用，假如一个表上有那么多索引，一个一个去看执行计划调试就很慢了，这时候不如建一个对表和查询都没有影响的Invisible Index来进行调试，就显得很好了。</p>
<p>&emsp;&emsp;通过下面的语句来操作索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> index idx_test_id invisible;</span><br><span class="line"><span class="keyword">alter</span> index idx_test_id visible;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果想让CBO看到Invisible Index，需要加入这句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> optimizer_use_invisible_indexes <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://yeqiu001.github.io/2021/04/02/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/" data-id="cknwys56x000in2euhqog8707" data-title="索引失效" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Index/" rel="tag">Index</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sql/" rel="tag">Sql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Ribbon的负载均衡策略及原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/01/Ribbon%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E5%8F%8A%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-04-01T09:15:03.000Z" itemprop="datePublished">2021-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringCloud/">SpringCloud</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/01/Ribbon%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E5%8F%8A%E5%8E%9F%E7%90%86/">SpringCloud组件：Ribbon的负载均衡策略及原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文章摘抄自网站博客，纯属兴趣摘抄自本博客</p>
</blockquote>
<p>&emsp;&emsp;Load Balance负载均衡是用于解决一台机器(一个进程)无法解决所有请求而产生的一种算法。像nginx可以使用负载均衡分配流量，ribbon为客户端提供负载均衡，dubbo服务调用里的负载均衡等等，很多地方都使用到了负载均衡。<br>&emsp;&emsp;使用负载均衡带来的好处很明显：</p>
<ul>
<li><p>当集群里的1台或者多台服务器down的时候，剩余的没有down的服务器可以保证服务的继续使用</p>
</li>
<li><p>使用了更多的机器保证了机器的良性使用，不会由于某一高峰时刻导致系统cpu急剧上升<br>&emsp;&emsp;负载均衡有好几种实现策略，常见的有：</p>
</li>
<li><p>随机 (Random)</p>
</li>
<li><p>轮询 (RoundRobin)</p>
</li>
<li><p>一致性哈希 (ConsistentHash)</p>
</li>
<li><p>哈希 (Hash)</p>
</li>
<li><p>加权（Weighted）</p>
<h3 id="ILoadBalance-负载均衡器"><a href="#ILoadBalance-负载均衡器" class="headerlink" title="ILoadBalance 负载均衡器"></a><strong>ILoadBalance 负载均衡器</strong></h3></li>
</ul>
<ol>
<li>&emsp;&emsp;<code>ribbon</code>是一个为客户端提供负载均衡功能的服务，它内部提供了一个叫做<code>ILoadBalance</code>的接口代表负载均衡器的操作，比如有添加服务器操作、选择服务器操作、获取所有的服务器列表、获取可用的服务器列表等等。</li>
</ol>
<p>&emsp;&emsp;<code>ILoadBalance</code>的继承关系如下：</p>
<img src="/2021/04/01/Ribbon%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E5%8F%8A%E5%8E%9F%E7%90%86/ribbon1.png" class="">

<p>&emsp;&emsp;负载均衡器是从EurekaClient（EurekaClient的实现类为DiscoveryClient）获取服务信息，根据IRule去路由，并且根据IPing判断服务的可用性。</p>
<p>&emsp;&emsp;负载均衡器多久一次去获取一次从Eureka Client获取注册信息呢？在BaseLoadBalancer类下，BaseLoadBalancer的构造函数，该构造函数开启了一个PingTask任务setupPingTask();，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseLoadBalancer</span><span class="params">(String name, IRule rule, LoadBalancerStats stats,</span></span></span><br><span class="line"><span class="function"><span class="params">        IPing ping, IPingStrategy pingStrategy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;LoadBalancer:  initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ping = ping;</span><br><span class="line">    <span class="keyword">this</span>.pingStrategy = pingStrategy;</span><br><span class="line">    setRule(rule);</span><br><span class="line">    setupPingTask();</span><br><span class="line">    lbStats = stats;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;setupPingTask()的具体代码逻辑，它开启了ShutdownEnabledTimer执行PingTask任务，在默认情况下pingIntervalSeconds为10，即每10秒钟，向EurekaClient发送一次”ping”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupPingTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (canSkipPing()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lbTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lbTimer.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        lbTimer = <span class="keyword">new</span> ShutdownEnabledTimer(<span class="string">&quot;NFLoadBalancer-PingTimer-&quot;</span> + name,</span><br><span class="line">                <span class="keyword">true</span>);</span><br><span class="line">        lbTimer.schedule(<span class="keyword">new</span> PingTask(), <span class="number">0</span>, pingIntervalSeconds * <span class="number">1000</span>);</span><br><span class="line">        forceQuickPing();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;PingTask源码，即new一个Pinger对象，并执行runPinger()方法。</p>
<p>&emsp;&emsp;查看Pinger的runPinger()方法，最终根据 pingerStrategy.pingServers(ping, allServers)来获取服务的可用性，如果该返回结果，如之前相同，则不去向EurekaClient获取注册列表，如果不同则通知ServerStatusChangeListener或者changeListeners发生了改变，进行更新或者重新拉取。</p>
<p><strong>完整过程是：</strong></p>
<p>&emsp;&emsp;LoadBalancerClient（RibbonLoadBalancerClient是实现类）在初始化的时候（execute方法），会通过ILoadBalance（BaseLoadBalancer是实现类）向Eureka注册中心获取服务注册列表，并且每10s一次向EurekaClient发送“ping”，来判断服务的可用性，如果服务的可用性发生了改变或者服务数量和之前的不一致，则从注册中心更新或者重新拉取。LoadBalancerClient有了这些服务注册列表，就可以根据具体的IRule来进行负载均衡。</p>
<p><strong>IRule 路由</strong></p>
<p>&emsp;&emsp;IRule接口代表负载均衡策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRule</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">getLoadBalancer</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;IRule接口的实现类有以下几种：</p>
<img src="/2021/04/01/Ribbon%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E5%8F%8A%E5%8E%9F%E7%90%86/ribbon2.png" class="">

<img src="/2021/04/01/Ribbon%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E5%8F%8A%E5%8E%9F%E7%90%86/ribbon3.png" class="">

<p>&emsp;&emsp;其中RandomRule表示随机策略、RoundRobinRule表示轮询策略、WeightedResponseTimeRule表示加权策略、BestAvailableRule表示请求数最少策略等等。</p>
<p>&emsp;&emsp;随机策略很简单，就是从服务器中随机选择一个服务器，RandomRule的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Server&gt; upList = lb.getReachableServers();</span><br><span class="line">        List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line">        <span class="keyword">int</span> serverCount = allList.size();</span><br><span class="line">        <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = rand.nextInt(serverCount); <span class="comment">// 使用jdk内部的Random类随机获取索引值index</span></span><br><span class="line">        server = upList.get(index); <span class="comment">// 得到服务器实例</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (server);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        server = <span class="keyword">null</span>;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;RoundRobinRule轮询策略表示每次都取下一个服务器，比如一共有5台服务器，第1次取第1台，第2次取第2台，第3次取第3台，以此类推：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;no load balancer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (server == <span class="keyword">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">        List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">        <span class="keyword">int</span> upCount = reachableServers.size();</span><br><span class="line">        <span class="keyword">int</span> serverCount = allServers.size();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ((upCount == <span class="number">0</span>) || (serverCount == <span class="number">0</span>)) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;No up servers available from load balancer: &quot;</span> + lb);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> nextServerIndex = incrementAndGetModulo(serverCount);</span><br><span class="line">        server = allServers.get(nextServerIndex);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Transient. */</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">            <span class="keyword">return</span> (server);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Next.</span></span><br><span class="line">        server = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;No available alive servers after 10 tries from load balancer: &quot;</span></span><br><span class="line">                + lb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inspired by the implementation of &#123;<span class="doctag">@link</span> AtomicInteger#incrementAndGet()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modulo The modulo to bound the value of the counter.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The next value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementAndGetModulo</span><span class="params">(<span class="keyword">int</span> modulo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = nextServerCyclicCounter.get();</span><br><span class="line">        <span class="keyword">int</span> next = (current + <span class="number">1</span>) % modulo;</span><br><span class="line">        <span class="keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;WeightedResponseTimeRule继承了RoundRobinRule，开始的时候还没有权重列表，采用父类的轮询方式，有一个默认每30秒更新一次权重列表的定时任务，该定时任务会根据实例的响应时间来更新权重列表，choose方法做的事情就是，用一个(0,1)的随机double数乘以最大的权重得到randomWeight，然后遍历权重列表，找出第一个比randomWeight大的实例下标，然后返回该实例，代码略。</p>
<p>&emsp;&emsp;BestAvailableRule策略用来选取最少并发量请求的服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loadBalancerStats == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.choose(key);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Server&gt; serverList = getLoadBalancer().getAllServers(); <span class="comment">// 获取所有的服务器列表</span></span><br><span class="line">    <span class="keyword">int</span> minimalConcurrentConnections = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">    Server chosen = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Server server: serverList) &#123; <span class="comment">// 遍历每个服务器</span></span><br><span class="line">        ServerStats serverStats = loadBalancerStats.getSingleServerStat(server); <span class="comment">// 获取各个服务器的状态</span></span><br><span class="line">        <span class="keyword">if</span> (!serverStats.isCircuitBreakerTripped(currentTime)) &#123; <span class="comment">// 没有触发断路器的话继续执行</span></span><br><span class="line">            <span class="keyword">int</span> concurrentConnections = serverStats.getActiveRequestsCount(currentTime); <span class="comment">// 获取当前服务器的请求个数</span></span><br><span class="line">            <span class="keyword">if</span> (concurrentConnections &lt; minimalConcurrentConnections) &#123; <span class="comment">// 比较各个服务器之间的请求数，然后选取请求数最少的服务器并放到chosen变量中</span></span><br><span class="line">                minimalConcurrentConnections = concurrentConnections;</span><br><span class="line">                chosen = server;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (chosen == <span class="keyword">null</span>) &#123; <span class="comment">// 如果没有选上，调用父类ClientConfigEnabledRoundRobinRule的choose方法，也就是使用RoundRobinRule轮询的方式进行负载均衡        </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.choose(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> chosen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用Ribbon提供的负载均衡策略很简单，只需以下几部：</p>
<p><strong>1、创建具有负载均衡功能的RestTemplate实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用RestTemplate进行rest操作的时候，会自动使用负载均衡策略，它内部会在RestTemplate中加入LoadBalancerInterceptor这个拦截器，这个拦截器的作用就是使用负载均衡。</p>
<p>&emsp;&emsp;默认情况下会采用轮询策略，如果希望采用其它策略，则指定IRule实现，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BestAvailableRule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这种方式对Feign也有效。</p>
<p>&emsp;&emsp;我们也可以参考ribbon，自己写一个负载均衡实现类。</p>
<p>&emsp;&emsp;可以通过下面方法获取负载均衡策略最终选择了哪个服务实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"> LoadBalancerClient loadBalancerClient; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//测试负载均衡最终选中哪个实例</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getChoosedService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="string">&quot;USERINFO-SERVICE&quot;</span>);</span><br><span class="line">     StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">     sb.append(<span class="string">&quot;host: &quot;</span>).append(serviceInstance.getHost()).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">     sb.append(<span class="string">&quot;port: &quot;</span>).append(serviceInstance.getPort()).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">     sb.append(<span class="string">&quot;uri: &quot;</span>).append(serviceInstance.getUri());</span><br><span class="line">     <span class="keyword">return</span> sb.toString();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://yeqiu001.github.io/2021/04/01/Ribbon%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E5%8F%8A%E5%8E%9F%E7%90%86/" data-id="cknwys56l0003n2eu3sm8akr3" data-title="SpringCloud组件：Ribbon的负载均衡策略及原理" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ribbon/" rel="tag">Ribbon</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-事务注解-Transactional失效的3种场景及解决办法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/31/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional%E5%A4%B1%E6%95%88%E7%9A%843%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-03-31T06:16:48.000Z" itemprop="datePublished">2021-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/31/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional%E5%A4%B1%E6%95%88%E7%9A%843%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">事务注解@Transactional失效的3种场景及解决办法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本问引用自博客： <a href="blog.csdn.net/qq_20597727/article/details/84900994">一撸向北</a></p>
</blockquote>
<h2 id="一、Transactional失效场景介绍"><a href="#一、Transactional失效场景介绍" class="headerlink" title="一、Transactional失效场景介绍"></a>一、<strong>Transactional失效场景介绍</strong></h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a><strong>第一种</strong></h3><p>&emsp;&emsp;<code>Transactional</code>注解标注方法修饰符为非public时，<code>@Transactional</code>注解将会不起作用，例如以下代码，定义一个错误的<code>@Transactional</code>标注实现，修饰一个默认访问符的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    TestMapper testMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认修饰符为default</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertTestWrongModifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在同一个包内，新建调用对象，进行访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokcationService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TestServiceImpl testService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeInsertTestWrongModifier</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用@Transactional标注的默认访问符方法</span></span><br><span class="line">        testService.insertTestWrongModifier();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;测试用例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   InvokcationService invokcationService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">testInvoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">      invokcationService.invokeInsertTestWrongModifier();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上的访问方式，导致事务没开启，因此在方法抛出异常时，<code>testMapper.insert(new Test(10,20,30))</code>;操作不会进行回滚。如果<code>TestServiceImpl#insertTestWrongModifier</code>方法由default改为public的话将会正常开启事务，testMapper.insert(new Test(10,20,30));将会进行回滚。</p>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a><strong>第二种</strong></h3><p>&emsp;&emsp;在类内部调用调用同一类内部<code>@Transactional</code>标注的方法。这种情况下也会导致事务不开启。示例代码如下，设置一个内部调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    TestMapper testMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTestInnerInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//正常public修饰符的事务方法</span></span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInnerInvoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//类内部调用@Transactional标注的方法。</span></span><br><span class="line">        insertTestInnerInvoke();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;测试用例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   TestServiceImpl testService;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 测试内部调用<span class="doctag">@Transactional</span>标注方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">testInnerInvoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//测试外部调用事务方法是否正常</span></span><br><span class="line">      <span class="comment">//testService.insertTestInnerInvoke();</span></span><br><span class="line">       <span class="comment">//测试内部调用事务方法是否正常</span></span><br><span class="line">      testService.testInnerInvoke();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面就是使用的测试代码，运行测试知道，外部调用事务方法能够征程开启事务，<code>testMapper.insert(new Test(10,20,30))</code>操作将会被回滚；</p>
<p>&emsp;&emsp;然后运行另外一个测试用例，调用一个方法在类内部调用内部被@Transactional标注的事务方法，运行结果是事务不会正常开启，<code>testMapper.insert(new Test(10,20,30))</code>操作将会保存到数据库不会进行回滚。</p>
<h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a><strong>第三种</strong></h3><p>&emsp;emsp;事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    TestMapper testMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTestCatchException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">            <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//运行期间抛异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i catch exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   TestServiceImpl testService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCatchException</span><span class="params">()</span></span>&#123;</span><br><span class="line">      testService.insertTestCatchException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;运行测试用例发现，虽然抛出异常，但是异常被捕捉了，没有抛出到方法 外，<code> testMapper.insert(new Test(210,20,30))</code>操作并没有回滚。</p>
<p>&emsp;&emsp;以上三种就是@Transactional注解不起作用，<code>@Transactional</code>注解失效的主要原因。下面结合spring中对于<code>@Transactional</code>的注解实现源码分析为何导致<code>@Transactional</code>注解不起作用。</p>
<h2 id="二、-Transactional注解不起作用原理分析"><a href="#二、-Transactional注解不起作用原理分析" class="headerlink" title="二、**@Transactional注解不起作用原理分析**"></a>二、**@Transactional注解不起作用原理分析**</h2><h3 id="第一种-1"><a href="#第一种-1" class="headerlink" title="第一种"></a><strong>第一种</strong></h3><p>&emsp;&emsp;<code>@Transactional</code>注解标注方法修饰符为非public时，<code>@Transactional</code>注解将会不起作用。这里分析 的原因是，<code>@Transactional</code>是基于动态代理实现的，<code>@Transactional</code>注解实现原理中分析了实现方法，在bean初始化过程中，对含有<code>@Transactional</code>标注的bean实例创建代理对象，这里就存在一个spring扫描<code>@Transactional</code>注解信息的过程，不幸的是源码中体现，标注@Transactional的方法如果修饰符不是public，那么就默认方法的<code>@Transactional</code>信息为空，那么将不会对bean进行代理对象创建或者不会对方法进行代理调用</p>
<p>&emsp;&emsp;<code>@Transactional</code>注解实现原理中，介绍了如何判定一个bean是否创建代理对象，大概逻辑是，根据spring创建好一个aop切点<code>BeanFactoryTransactionAttributeSourceAdvisor</code>实例，遍历当前bean的class的方法对象，判断方法上面的注解信息是否包含<code>@Transactional</code>，如果bean任何一个方法包含<code>@Transactional</code>注解信息，那么就是适配这个BeanFactoryTransactionAttributeSourceAdvisor切点。则需要创建代理对象，然后代理逻辑为我们管理事务开闭逻辑。</p>
<p>&emsp;&emsp;spring源码中，在拦截bean的创建过程，寻找bean适配的切点时，运用到下面的方法，目的就是寻找方法上面的<code>@Transactional</code>信息，如果有，就表示切点<code>BeanFactoryTransactionAttributeSourceAdvisor</code>能够应用（canApply）到bean中，<code>AopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class&lt;?&gt;, boolean)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">   Assert.notNull(pc, <span class="string">&quot;Pointcut must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">   <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">      <span class="comment">// No need to iterate the methods if we&#x27;re matching any method anyway...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">      introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历class的方法对象</span></span><br><span class="line">   Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line">   classes.add(targetClass);</span><br><span class="line">   <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">      Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((introductionAwareMethodMatcher != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               introductionAwareMethodMatcher.matches(method, targetClass,hasIntroductions))||</span><br><span class="line">             <span class="comment">//适配查询方法上的@Transactional注解信息  </span></span><br><span class="line">             methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以在上面的方法打断点，一步一步调试跟踪代码，最终上面的代码还会调用如下方法来判断。在下面的方法上断点，回头看看方法调用堆栈也是不错的方式跟踪。推荐：</p>
<p>&emsp;&emsp;<strong>AbstractFallbackTransactionAttributeSource#getTransactionAttribute</strong></p>
<p>&emsp;&emsp;<strong>AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">   <span class="comment">//非public 方法，返回@Transactional信息一律是null</span></span><br><span class="line">   <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//后面省略.......</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="不创建代理对象"><a href="#不创建代理对象" class="headerlink" title="不创建代理对象"></a><strong>不创建代理对象</strong></h4><p>&emsp;&emsp;所以，如果所有方法上的修饰符都是非public的时候，那么将不会创建代理对象。以一开始的测试代码为例，如果正常的修饰符的testService是下面图片中的，经过cglib创建的代理对象。</p>
<img src="/2021/03/31/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional%E5%A4%B1%E6%95%88%E7%9A%843%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/trans1.png" class="">

<p>&emsp;&emsp;如果class中的方法都是非public的那么将不是代理对象。</p>
<img src="/2021/03/31/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional%E5%A4%B1%E6%95%88%E7%9A%843%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/trans2.png" class="">

<h4 id="不进行代理调用"><a href="#不进行代理调用" class="headerlink" title="不进行代理调用"></a><strong>不进行代理调用</strong></h4><p>&emsp;&emsp;考虑一种情况，如下面代码所示。两个方法都被@Transactional注解标注，但是一个有public修饰符一个没有，那么这种情况我们可以预见的话，一定会创建代理对象，因为至少有一个public修饰符的@Transactional注解标注方法。</p>
<p>&emsp;&emsp;创建了代理对象，insertTestWrongModifier就会开启事务吗？答案是不会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    TestMapper testMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertTestWrongModifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;原因是在动态代理对象进行代理逻辑调用时，在cglib创建的代理对象的拦截函数中<code>CglibAopProxy.DynamicAdvisedInterceptor#intercept</code>，有一个逻辑如下，目的是获取当前被代理对象的当前需要执行的method适配的aop逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; chain &#x3D; this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;而针对@Transactional注解查找aop逻辑过程，相似地，也是执行一次</p>
<p>&emsp;&emsp;<strong>AbstractFallbackTransactionAttributeSource#getTransactionAttribute</strong><br>&emsp;&emsp;<strong>AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</strong></p>
<p>也就是说还需要找一个方法上的@Transactional注解信息，没有的话就不执行代理@Transactional对应的代理逻辑，直接执行方法。没有了@Transactional注解代理逻辑，就无法开启事务，这也是上一篇已经讲到的。</p>
<h4 id="第二种-1"><a href="#第二种-1" class="headerlink" title="第二种"></a><strong>第二种</strong></h4><p>&emsp;&emsp;在类内部调用调用类内部@Transactional标注的方法。这种情况下也会导致事务不开启。</p>
<p>&emsp;&emsp;经过对第一种的详细分析，对这种情况为何不开启事务管理，原因应该也能猜到；</p>
<blockquote>
<p>&emsp;&emsp;既然事务管理是基于动态代理对象的代理逻辑实现的，那么如果在类内部调用类内部的事务方法，这个调用事务方法的过程并不是通过代理对象来调用的，而是直接通过this对象来调用方法，绕过的代理对象，肯定就是没有代理逻辑了。</p>
</blockquote>
<p>&emsp;&emsp;其实我们可以这样玩，内部调用也能实现开启事务，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    TestMapper testMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    TestServiceImpl testServiceImpl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTestInnerInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInnerInvoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//内部调用事务方法</span></span><br><span class="line">        testServiceImpl.insertTestInnerInvoke();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面就是使用了代理对象进行事务调用，所以能够开启事务管理，但是实际操作中，没人会闲的蛋疼这样子玩。</p>
<h4 id="第三种-1"><a href="#第三种-1" class="headerlink" title="第三种"></a><strong>第三种</strong></h4><p>&emsp;&emsp;事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。</p>
<p>&emsp;&emsp;这种的话，可能我们比较常见，问题就出在代理逻辑中，我们先看看源码里面动态代理逻辑是如何为我们管理事务的。</p>
<p>&emsp;&emsp;<strong>TransactionAspectSupport#invokeWithinTransaction</strong></p>
<p>&emsp;&emsp;代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">   <span class="keyword">final</span> TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">   <span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">   <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">      <span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">       <span class="comment">//开启事务</span></span><br><span class="line">      TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">      Object retVal = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">         <span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">          <span class="comment">//反射调用业务方法</span></span><br><span class="line">         retVal = invocation.proceedWithInvocation();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="comment">// target invocation exception</span></span><br><span class="line">          <span class="comment">//异常时，在catch逻辑中回滚事务</span></span><br><span class="line">         completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         cleanupTransactionInfo(txInfo);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//提交事务</span></span><br><span class="line">      commitTransactionAfterReturning(txInfo);</span><br><span class="line">      <span class="keyword">return</span> retVal;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//....................</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所以看了上面的代码就一目了然了，事务想要回滚，必须能够在这里捕捉到异常才行，如果异常中途被捕捉掉，那么事务将不会回滚。</p>
<p>&emsp;&emsp;总结了以上几种情况。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yeqiu001.github.io/2021/03/31/%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional%E5%A4%B1%E6%95%88%E7%9A%843%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" data-id="cknwys56w000gn2eubp011bvn" data-title="事务注解@Transactional失效的3种场景及解决办法" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Annotation/" rel="tag">Annotation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Transactional/" rel="tag">Transactional</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-objective" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/29/objective/" class="article-date">
  <time class="dt-published" datetime="2021-03-29T03:39:46.000Z" itemprop="datePublished">2021-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%97%A5%E5%B8%B8%E8%AE%A1%E5%88%92/">日常计划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/29/objective/">objective</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-短期目标：第一阶段"><a href="#1-短期目标：第一阶段" class="headerlink" title="1.短期目标：第一阶段"></a>1.短期目标：第一阶段</h2><h3 id="1-1-输出Spring-Security-原理文档（简单讲解，后续会陆续增加详细说明，在后续目标中再确定）"><a href="#1-1-输出Spring-Security-原理文档（简单讲解，后续会陆续增加详细说明，在后续目标中再确定）" class="headerlink" title="1.1 输出Spring Security 原理文档（简单讲解，后续会陆续增加详细说明，在后续目标中再确定）"></a>1.1 输出Spring Security 原理文档（简单讲解，后续会陆续增加详细说明，在后续目标中再确定）</h3><h3 id="1-2-输出Spring-Security-Demo学习文档（包含简单的源码讲解）"><a href="#1-2-输出Spring-Security-Demo学习文档（包含简单的源码讲解）" class="headerlink" title="1.2 输出Spring Security Demo学习文档（包含简单的源码讲解）"></a>1.2 输出Spring Security Demo学习文档（包含简单的源码讲解）</h3><h3 id="1-3-输出Spring-Security核心源码学习文档"><a href="#1-3-输出Spring-Security核心源码学习文档" class="headerlink" title="1.3 输出Spring Security核心源码学习文档"></a>1.3 输出Spring Security核心源码学习文档</h3><h3 id="1-4-学习OAuth2-0框架"><a href="#1-4-学习OAuth2-0框架" class="headerlink" title="1.4 学习OAuth2.0框架"></a>1.4 学习OAuth2.0框架</h3><h4 id="1-5-输出OAuth2-0原理文档"><a href="#1-5-输出OAuth2-0原理文档" class="headerlink" title="1.5 输出OAuth2.0原理文档"></a>1.5 输出OAuth2.0原理文档</h4><p>……</p>
<h2 id="每日目标"><a href="#每日目标" class="headerlink" title="每日目标"></a>每日目标</h2><blockquote>
<p>保证每日更新博客内容</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yeqiu001.github.io/2021/03/29/objective/" data-id="cknwys56t000bn2eu83s79anj" data-title="objective" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/target/" rel="tag">target</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SpringSecurityDemoStudy" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/25/SpringSecurityDemoStudy/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T16:00:00.000Z" itemprop="datePublished">2021-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring-Security/">Spring Security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/25/SpringSecurityDemoStudy/">Spring Security Demo 学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本问主要基于Spring boot框架进行Demo说明，首先创建一个Springboot 工程。</p>
</blockquote>
<h3 id="1-创建Springboot-工程"><a href="#1-创建Springboot-工程" class="headerlink" title="1.创建Springboot 工程"></a>1.创建Springboot 工程</h3><h3 id="2-引入Spring-Security-依赖"><a href="#2-引入Spring-Security-依赖" class="headerlink" title="2.引入Spring Security 依赖"></a>2.引入Spring Security 依赖</h3><p>&emsp;&emsp;我们可以直接引入Spring Security 的starter包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当我们查看spring-boot-starter-security引入的依赖时，我们可以看到starter主要引入了Spring Security的spring-security-config和spring-security-web包，我们也可以手动引入这两个包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-Demo学习"><a href="#3-Demo学习" class="headerlink" title="3.Demo学习"></a>3.Demo学习</h3><h4 id="3-1Spring-Security默认配置"><a href="#3-1Spring-Security默认配置" class="headerlink" title="3.1Spring Security默认配置"></a>3.1Spring Security默认配置</h4><p>&emsp;&emsp;我们建立的Spring boot工程默认端口号为8080，在引入Spring Security包之前，启动服务，访问<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a><br>&emsp;&emsp;此时页面显示404，无法找到页面；此时我们在将Spring Security的依赖引入，重启服务，再次访问服务，此时我们可以看到如下页面：</p>
<img src="/2021/03/25/SpringSecurityDemoStudy/securityform.png" class="">
<p>&emsp;&emsp;这是一个表单认证的登录页面，也就是说当引入Spring Security依赖后，服务就已经开启Spring Security的认证功能，那既然Spring Security既然引入依赖后就默认开启了认证功能，是不是就有默认的用户名和密码？其实Spring Security中有一个SecurityProperties配置类中的一个静态内部类中告诉了我们默认的用户名和密码，可以看到默认用户名和密码分别是user和uuid生成的一串随机码，此时我们只能明确一个用户名是user，密码的随机字符串我们却不知道。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Default user name.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Password for the default user name.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> String password = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Granted roles for the default user name.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; roles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> passwordGenerated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.password;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasLength(password)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.passwordGenerated = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">this</span>.password = password;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getRoles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.roles;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoles</span><span class="params">(List&lt;String&gt; roles)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.roles = <span class="keyword">new</span> ArrayList&lt;&gt;(roles);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPasswordGenerated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.passwordGenerated;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时我们查看这个内部类被谁调用过，是不是可以从调用处能够看到默认密码的信息，当我们查看调用方时，我们可以看到一个类名：UserDetailsServiceAutoConfiguration的类，如果认真看服务启动时打印的信息的话，可以看到控制台其实打印了这个类的信息：</p>
<img src="/2021/03/25/SpringSecurityDemoStudy/defaultpassword.png" class="">
<p>&emsp;&emsp;查看这个类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.security.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.ObjectProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.security.SecurityProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.ObjectPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.provisioning.InMemoryUserDetailsManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> EnableAutoConfiguration Auto-configuration&#125; for a Spring Security in-memory</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AuthenticationManager&#125;. Adds an &#123;<span class="doctag">@link</span> InMemoryUserDetailsManager&#125; with a</span></span><br><span class="line"><span class="comment"> * default user and generated password. This can be disabled by providing a bean of type</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AuthenticationManager&#125;, &#123;<span class="doctag">@link</span> AuthenticationProvider&#125; or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> UserDetailsService&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rob Winch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Madhura Bhave</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(AuthenticationManager.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(ObjectPostProcessor.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">        value = &#123; AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class &#125;,</span></span><br><span class="line"><span class="meta">        type = &#123; &quot;org.springframework.security.oauth2.jwt.JwtDecoder&quot;,</span></span><br><span class="line"><span class="meta">                &quot;org.springframework.security.oauth2.server.resource.introspection.OpaqueTokenIntrospector&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NOOP_PASSWORD_PREFIX = <span class="string">&quot;&#123;noop&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PASSWORD_ALGORITHM_PATTERN = Pattern.compile(<span class="string">&quot;^\\&#123;.+&#125;.*$&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(UserDetailsServiceAutoConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">            type = &quot;org.springframework.security.oauth2.client.registration.ClientRegistrationRepository&quot;)</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InMemoryUserDetailsManager <span class="title">inMemoryUserDetailsManager</span><span class="params">(SecurityProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">            ObjectProvider&lt;PasswordEncoder&gt; passwordEncoder)</span> </span>&#123;</span><br><span class="line">        SecurityProperties.User user = properties.getUser();</span><br><span class="line">        List&lt;String&gt; roles = user.getRoles();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InMemoryUserDetailsManager(</span><br><span class="line">                User.withUsername(user.getName()).password(getOrDeducePassword(user, passwordEncoder.getIfAvailable()))</span><br><span class="line">                        .roles(StringUtils.toStringArray(roles)).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getOrDeducePassword</span><span class="params">(SecurityProperties.User user, PasswordEncoder encoder)</span> </span>&#123;</span><br><span class="line">        String password = user.getPassword();</span><br><span class="line">        <span class="keyword">if</span> (user.isPasswordGenerated()) &#123;</span><br><span class="line">            logger.info(String.format(<span class="string">&quot;%n%nUsing generated security password: %s%n&quot;</span>, user.getPassword()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (encoder != <span class="keyword">null</span> || PASSWORD_ALGORITHM_PATTERN.matcher(password).matches()) &#123;</span><br><span class="line">            <span class="keyword">return</span> password;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NOOP_PASSWORD_PREFIX + password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这个类的注释可以知道，这个自动配置类时记忆了一个默认的用户，在定义AuthenticationManager、AuthenticationProvider、UserDetailsService中任一类时，这个自动配置类会被禁用。<br>&emsp;&emsp;我们可以看到在这个类的getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder)方法中通过日志的方式打印了密码的信息，那我们在看看之前截截图中打印的控制台信息，第二处标红就是上述类方法中打印的密码信息，此时我们已经知道了Spring Security在配置用户名和密码的情况下默认的用户密码为user和控制台打印出的随机码。<br>&emsp;&emsp;此时我们再访问<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> ,输入默认的用户名和密码，此时点击Sign in按钮后，页面跳转依然显示404，其实Spring Security已经验证了信息，这个404是我们未定义访问的接口返回的信息或需要跳转的页面。<br>&emsp;&emsp;我们可以定义一下访问接口的，在这之前我们先通过配置文件修改一下我们当前的用户名和密码，在配置文件中增加如下配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">zzjiang</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;重启服务，发现此前控制台打印的UserDetailsServiceAutoConfiguration信息和随机密码在控制台已经不打印了，此时我们在登录页输入我们配置的用户名和密码，发现效果和之前相同，但因为我们没有配置接口信息，无法确认验证是否进行及配置是否生效。<br>&emsp;&emsp;我们在服务中建一个测试的Controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yeqiu.demo.security.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzjiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时我们重启服务再去页面登录后查看效果，此时页面展示了我们接口中定义的Hello World的字符串，但此时是否说明我们Spring Security已经验证成功？还是说Spring Security没有做认证，只是提供了登录页面无论输入什么用户名和密码都会成功呢？？我们返回登录页面，输入一个错误的用户名或者密码来验证一下。<br>&emsp;&emsp;当我们输入错误的用户名或者密码时，我们可以看到页面并未跳转且登录页面显示“用户名或密码错误”，此时可以说明Spring Security已经对我们的请求进行了简单的认证。<br>&emsp;&emsp;但我们现在只是验证了引入了Spring Security的默认配置，但我们实际使用中需要做到Spring Security 的可配置，以适应我们项目的需求，Spring Security本身和Spring框架一样，提供了框架了可扩展性，所以后续过程中，我们就要实现的Spring Security的扩展性配置。</p>
<h4 id="3-2-Spring-Security-配置"><a href="#3-2-Spring-Security-配置" class="headerlink" title="3.2 Spring Security 配置"></a>3.2 Spring Security 配置</h4><p>&emsp;&emsp;要使用Spring Security的认证和鉴权功能以满足我们的产品，我们就需要知道如何去配置Spring Security以满足我们的需求使用。<br>&emsp;&emsp;根据Spring Security官网介绍，完成Spring Seccurity配置需要继承</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yeqiu001.github.io/2021/03/25/SpringSecurityDemoStudy/" data-id="cknwys56q0007n2eua3a80x7d" data-title="Spring Security Demo 学习" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Security/" rel="tag">Spring Security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/demo/" rel="tag">demo</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SpringSecurity原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/02/SpringSecurity%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-03-02T09:07:54.000Z" itemprop="datePublished">2021-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring-Security/">Spring Security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/02/SpringSecurity%E5%8E%9F%E7%90%86/">SpringSecurity原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SpringSecurity原理"><a href="#SpringSecurity原理" class="headerlink" title="SpringSecurity原理"></a><strong>SpringSecurity原理</strong></h1><h3 id="一、SpringSecurity过滤器链"><a href="#一、SpringSecurity过滤器链" class="headerlink" title="一、SpringSecurity过滤器链"></a>一、SpringSecurity过滤器链</h3><ol>
<li><code>SpringSecurity</code>的底层实现是一条过滤器链，也就是说用户进来后，由这些过滤器链判断是否有请求的权限，如果有权限则放过；没有权限的化就会抛出异常，重定向到要跳转的页面</li>
<li><code>SpringSecurity</code> 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤器链的各个进行说明:<br>&emsp;&emsp;2.1 <code>WebAsyncManagerIntegrationFilter</code>：将<code>Security</code>上下文与<code>Spring Web</code>中用于处理异步请求映射的<code>WebAsyncManager</code>进行集成;<br>&emsp;&emsp;2.2 <code>SecurityContextPersistenceFilter</code>：在每次请求处理之前将该请求相关的安全上下文信息加载到<code>SecurityContextHolder</code>中，然后在该次请求处理完成之后，将<code>SecurityContextHolder</code>中关于这次请求的信息存储到一个”仓储”中，然后将<code>SecurityContextHolder</code>中的信息清除，例如：在<code>Session</code>中维护一个用户的安全信息就是这个过滤器处理的;<br>&emsp;&emsp;2.3<code>HeaderWriterFilter</code>：用于将头信息加入到响应中;<br>&emsp;&emsp;2.4 <code>CsrfFilter</code>：用于处理跨站请求伪造;<br>&emsp;&emsp;2.5 <code>LogoutFilter</code>：用于处理退出登录;<br>&emsp;&emsp;2.6 <code>UsernamePasswordAuthenticationFilter</code>：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自/login的请求。从表单中获取用户名和密码时，默认使用的<code>name</code>的值为<code>username</code>和<code>password</code>，这两个值可以通过设置这个过滤器的<code>usernameParameter</code>和<code>passwordParameter</code>两个参数的值进行修改。<br>&emsp;&emsp;2.7 <code>DefaultLoginPageGeneratingFilter</code>：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且在需要进行登陆时生成一个登录表单页面。<br>&emsp;&emsp;2.8 <code>BasicAuthenticationFilter</code>：检测和处理<code>http basic</code>认证。<br>&emsp;&emsp;2.9 <code>RequestCacheAwareFilter</code>：用来处理请求的缓存。<br>&emsp;&emsp;2.10 <code>SecurityContextHolderAwareRequestFilter</code>：主要包装请求的<code>Requeest</code>。<br>&emsp;&emsp;2.11 <code>AnonymousAuthenticationFilter</code>： 检测<code>SecurityContextHolder</code>中是否存在<code>Authentication</code>对象，如果不存在为其提供一个匿名<code>Authentication</code>。<br>&emsp;&emsp;2.12 <code>SessionManagementFilter</code>：管理<code>session</code>的过滤器。<br>&emsp;&emsp;2.13 <code>ExceptionTranslationFilter</code>：处理<code>AccessDeniedException</code>和<code>AuthenticationException</code>异常。<br>&emsp;&emsp;2.14 <code>FilterSecurityInterceptor</code>：过滤器链的出口。<br>&emsp;&emsp;2.15 <code>RememberMeAuthenticationFilter</code>：当用户没有登录而直接访问资源时，从<code>cookie</code>中找出用户的信息，如果<code>Spring Security</code>能够识别出用户提供的<code>remember me cookie</code>,用户将不必填写用户名和密码，而是直接登录进入系统，该过滤器默认不开启。<h3 id="二、SpringSecurity流程图-如链接中流程图"><a href="#二、SpringSecurity流程图-如链接中流程图" class="headerlink" title="二、SpringSecurity流程图(如链接中流程图)"></a>二、SpringSecurity流程图(如链接中流程图)</h3>&emsp;&emsp;<a target="_blank" rel="noopener" href="http://note.youdao.com/noteshare?id=93708e50e2955cdd334c2400412c3ec0&sub=32EEFBB9B8CC4507B76C00F14EBD926B/">SpringSecurity流程图</a><img src="/2021/03/02/SpringSecurity%E5%8E%9F%E7%90%86/SpringSecurity%E5%8E%9F%E7%90%86.png" class=""></li>
</ol>
<h3 id="三、SpringSecurity流程说明"><a href="#三、SpringSecurity流程说明" class="headerlink" title="三、SpringSecurity流程说明"></a>三、SpringSecurity流程说明</h3><ol>
<li>客户端发起请求，进入过滤器链</li>
<li>当到<code>LogoutFilter</code>的时候判断是否是登出路径，如果是登出路径则到<code>LogoutHandler</code>，如果登出成功则到<code>logoutSuccessHandler</code>登出成功处理，如果登出失败则由<code>ExceptionTranslationFilter</code>，如果不是登出路径则直接进入下一个过滤器。</li>
<li>当到<code>UsernamePasswordAuthenticationFilter</code>的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到<code>AuthenticationFailureHandler</code>登录失败处理器处理，如果登录成功则到<code>AuthenticationSuccessHandler</code>登录成功处理器处理，如果不是登录请求则不进入该过滤器。</li>
<li>当到<code>FilterSecurityInterceptor</code>的时候会拿到uri，根据uri去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到<code>Controller</code>层否则到<code>AccessDeniedHandler</code>鉴权失败处理器处理。<h3 id="四、SpringSecurity配置-简单介绍，详细使用方案会在后续使用文档中说明，本文档主要是介绍文档"><a href="#四、SpringSecurity配置-简单介绍，详细使用方案会在后续使用文档中说明，本文档主要是介绍文档" class="headerlink" title="四、SpringSecurity配置(简单介绍，详细使用方案会在后续使用文档中说明，本文档主要是介绍文档)"></a>四、SpringSecurity配置(简单介绍，详细使用方案会在后续使用文档中说明，本文档主要是介绍文档)</h3>&emsp;&emsp;<code>Springboot</code>需要在<code>WebSecurityconfigurerAdapter</code>这个类中实现上述流程图的配置，代码中需要实现这个类并重写其中需要使用的方法<h4 id="配置伪代码"><a href="#配置伪代码" class="headerlink" title="配置伪代码"></a>配置伪代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">config</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(<span class="keyword">new</span> BCryptPasswordEncoder());  <span class="comment">//Security默认MD5加密方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;	</span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/resources/**/*.html&quot;</span>, <span class="string">&quot;/resources/**/*.js&quot;</span>);	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">config</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        http.formLogin.loginPage(<span class="string">&quot;login_page&quot;</span>)</span><br><span class="line">            .passwordParameter(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">            .passwordParameter(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/sign_in&quot;</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and().authorizeRequests().antMatchers(<span class="string">&quot;/test&quot;</span>).hasRole(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">            .anyRequest().authenticated().accessDecisionManager(accessDecisionManager())</span><br><span class="line">            .and().logout().logoutSuccessHandler(<span class="keyword">new</span> MyLogoutSuccessHandler())</span><br><span class="line">            .and().csrf().disable();</span><br><span class="line">        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        http.exceptionHandling().accessDeniedHandler(<span class="keyword">new</span> MyAccessDeniedHandler());</span><br><span class="line">        http.addFilterAfter(<span class="keyword">new</span> MyFittler(), LogoutFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置简介"><a href="#配置简介" class="headerlink" title="配置简介"></a>配置简介</h4>&emsp;&emsp;<code>config(AuthenticationManagerBuilder auth)</code> 配置Security认证的方法，<code>AuthenticationManagerBuilder</code>见明知义，就是构建一个<code>Authentication</code>的管理器，该类的功能参考<code>SpringSecurity</code>流程图中<code>AuthenticationManager</code>部分所示，该部分可以配置<code>UserDetailsService</code>和<code>PasswordEncoder</code>。<code>UserDetailsService</code>用于在认证器中根据用户传过来的用户名查找一个用户，在使用过程中，可以实现该接口，重写其中的方法，加载一个<code>UserDeatils</code>信息，认证通过后就会将该对象赋给认证通过的<code>Authentication</code>的<code>Principal</code>对象，后续需要对象信息时就通过<code>SecurityContextHolder</code>获取存放在<code>SecurityContext</code>中的<code>Authentication</code>的<code>principal</code>。<code>PasswordEncoder</code>用于密码的加密与比对，可以自定义加密方法。<br>&emsp;&emsp;<code>configure(WebSecurity web)</code> 配置静态资源的权限。<br>&emsp;&emsp;<code>config(HttpSecurity http)</code> 这个配置方法是<code>WebSecurityConfigurerAdapter</code>的核心配置方法，每个配置我们可以分开说明。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin.loginPage(<span class="string">&quot;login_page&quot;</span>)</span><br><span class="line">    .passwordParameter(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    .passwordParameter(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">    .loginProcessingUrl(<span class="string">&quot;/sign_in&quot;</span>)</span><br><span class="line">    .permitAll()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此段代码配置了登录页请求路径，密码属性名，用户名属性名，和登录请求路径,<code>permitAll()</code>代表任意用户可访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests().antMatchers(<span class="string">&quot;/test&quot;</span>)</span><br><span class="line">    .hasRole(<span class="string">&quot;test&quot;</span>).anyRequest().authenticated()</span><br><span class="line">    .accessDecisionManager(accessDecisionManager())</span><br></pre></td></tr></table></figure>
<p>​        此段代码是对权限的配置，这段代码表示访问/test的URL时需要有test的权限方可访问，<code>anyRequest() </code>表示任意请求，<code>authenticated()</code>表示需要通过认证，<code>accessDecisionManager()</code> 表示绑定在url上的鉴权管理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.logout().logoutSuccessHandler(<span class="keyword">new</span> MyLogoutSuccessHandler())</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用户登出时的相关配置，<code>new MyLogoutSuccessHandler()</code>登出成功后的处理，可自定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.csrf().disable();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此段代码是关闭csrf。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.exceptionHandling().accessDeniedHandler(<span class="keyword">new</span> MyAccessDeniedHandler());</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此段代码是配置鉴权失败的处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterAfter(<span class="keyword">new</span> MyFittler(), LogoutFilter.class);</span><br><span class="line">http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;代码展示如何在过滤器链中插入自己的过滤器，<code>addFilterBefore</code>加在对应的过滤器之前，<code>addFilterAfter</code>加在对应的过滤器之后，<code>addFilterAt</code>加在过滤器同一位置，事实上框架原有的<code>Filter</code>在启动<code>HttpSecurity</code>配置的过程中，都由框架完成了其一定程度上固定的配置，是不允许更改替换的。根据测试结果来看，调用<code>addFilterAt</code>方法插入的<code>Filter</code>，会在这个位置上的原有<code>Filter</code>之前执行。</p>
<h3 id="五、SpringSecurity权限系统"><a href="#五、SpringSecurity权限系统" class="headerlink" title="五、SpringSecurity权限系统"></a>五、SpringSecurity权限系统</h3><h4 id="UserDeatils"><a href="#UserDeatils" class="headerlink" title="UserDeatils"></a>UserDeatils</h4><p>&emsp;&emsp;<code>SpringSecurity</code>定义的用户接口，当我们需要自定义一些属性时，需要实现该接口。</p>
<h4 id="GrantedAuthority"><a href="#GrantedAuthority" class="headerlink" title="GrantedAuthority"></a>GrantedAuthority</h4><p>&emsp;&emsp;<code>SpringSecurity</code>定义的用户权限接口，自定义权限需要实现该接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGrantedAuthority</span> <span class="keyword">implements</span> <span class="title">GrantedAuthority</span> </span>&#123;	</span><br><span class="line">    <span class="keyword">private</span> String authority;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>authority</code>是权限字段，需要注意的是在config中配置的权限会被加上<code>ROLE_</code>前缀，比如我们的配置<code>authorizeRequests().antMatchers(&quot;/test&quot;).hasRole(&quot;test&quot;)</code>，配置了一个test权限但我们存储的权限字段（authority）应该是<code>ROLE_test</code>。</p>
<h4 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h4><p>&emsp;&emsp;<code>Security</code>中的用户<code>Service</code>，自定义用户服务类需要实现该接口,我们在<code>loadUserByUsername</code>中根据传入的用户名查询我们当前系统对应该对象的用户名和权限，构造<code>UserDetails</code>对象，再有框架去验证传入的对象信息和我们系统的对象信息是否一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;	</span><br><span class="line">    <span class="meta">@Override</span>	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;	</span><br><span class="line">      return.....	</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h4><p>&emsp;&emsp;用户在完成登录后 <code>Security</code> 会将用户信息存储到这个类中，之后其他流程需要得到用户信息时都是从这个类中获得，用户信息被封装成 SecurityContext ，而实际存储的类是<code>SecurityContextHolderStrategy</code>，默认的<code>SecurityContextHolderStrategy</code> 实现类是 <code>ThreadLocalSecurityContextHolderStrategy</code> 它使用了<code>ThreadLocal</code>来存储了用户信息。<br>&emsp;&emsp;手动填充<code> SecurityContextHolder</code> 示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UsernamePasswordAuthenticationToken token &#x3D; new UsernamePasswordAuthenticationToken(&quot;test&quot;,&quot;test&quot;,list);	</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(token);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于使用 token 鉴权的系统，我们就可以验证token后手动填充<code>SecurityContextHolder</code>，填充时机只要在执行投票器之前即可，或者干脆可以在投票器中填充，然后在登出操作中清空<code>SecurityContextHolder</code>。</p>
<h3 id="Security扩展"><a href="#Security扩展" class="headerlink" title="Security扩展"></a>Security扩展</h3><p>&emsp;&emsp;可扩展的部分有:</p>
<h5 id="emsp-emsp-1-鉴权失败处理器"><a href="#emsp-emsp-1-鉴权失败处理器" class="headerlink" title="&emsp;&emsp;1.鉴权失败处理器"></a>&emsp;&emsp;1.鉴权失败处理器</h5><p>&emsp;&emsp;Security 鉴权失败默认跳转登录页面，我们可以实现<code>AccessDeniedHandler</code>接口，重写 handle() 方法来自定义处理逻辑；然后参考配置类说明将处理器加入到配置当中。</p>
<h5 id="emsp-emsp-2-验证器"><a href="#emsp-emsp-2-验证器" class="headerlink" title="&emsp;&emsp;2.验证器"></a>&emsp;&emsp;2.验证器</h5><p>&emsp;&emsp;实现<code> AuthenticationProvider</code> 接口来实现自己验证逻辑。需要注意的是在这个类里面就算你抛出异常，也不会中断验证流程，而是算你验证失败，我们由流程图知道，只要有一个验证器验证成功，就算验证成功，所以你需要留意这一点。</p>
<h5 id="emsp-emsp-3-登录成功处理器"><a href="#emsp-emsp-3-登录成功处理器" class="headerlink" title="&emsp;&emsp;3.登录成功处理器"></a>&emsp;&emsp;3.登录成功处理器</h5><p>&emsp;&emsp;在Security中验证成功默认跳转到上一次请求页面或者路径为 “/“ 的页面，我们同样可以自定义：继承SimpleUrlAuthenticationSuccessHandler这个类或者实现<code>AuthenticationSuccessHandler</code>接口。我这里建议采用继承的方式,<code>SimpleUrlAuthenticationSuccessHandler</code>是默认的处理器，采用继承可以契合里氏替换原则，提高代码的复用性和避免不必要的错误。</p>
<h5 id="emsp-emsp-4-投票器"><a href="#emsp-emsp-4-投票器" class="headerlink" title="&emsp;&emsp;4.投票器"></a>&emsp;&emsp;4.投票器</h5><p>&emsp;&emsp;投票器可继承<code>WebExpressionVoter</code>或者实现 <code>AccessDecisionVoter</code>接口；<code>WebExpressionVoter</code>是<code>Security</code>默认的投票器；我这里同样建议采用继承的方式；添加到配置的方式参考上文；<br>&emsp;&emsp;<strong>注意：投票器 vote 方法返回一个int值；-1代表反对，0代表弃权，1代表赞成；投票管理器收集投票结果，如果最终结果大于等于0则放行该请求。</strong></p>
<h5 id="emsp-emsp-5-自定义token处理过滤器"><a href="#emsp-emsp-5-自定义token处理过滤器" class="headerlink" title="&emsp;&emsp;5.自定义token处理过滤器"></a>&emsp;&emsp;5.自定义token处理过滤器</h5><p>&emsp;&emsp;自定义 token 处理器继承自 <code>OncePerRequestFilter</code> 或者 <code>GenericFilterBean</code> 或者 <code>Filter</code> 都可以，在这个处理器里面需要完成的逻辑是：获取请求里的 token，验证 token 是否合法然后填充 <code>SecurityContextHolder</code> ，虽然说过滤器只要添加在投票器之前就可以，但我这里还是建议添加在 <code>http.addFilterAfter(new MyFittler(), LogoutFilter.class)</code>;</p>
<h5 id="emsp-emsp-6-登出成功处理器"><a href="#emsp-emsp-6-登出成功处理器" class="headerlink" title="&emsp;&emsp;6.登出成功处理器"></a>&emsp;&emsp;6.登出成功处理器</h5><p>&emsp;&emsp;实现<code>LogoutSuccessHandler</code>接口，添加到配置的方式参考上文。</p>
<h5 id="emsp-emsp-7-登出失败处理器"><a href="#emsp-emsp-7-登出失败处理器" class="headerlink" title="&emsp;&emsp;7.登出失败处理器"></a>&emsp;&emsp;7.登出失败处理器</h5><p>&emsp;&emsp;登录失败默认跳转到登录页，我们同样可以自定义。继承<code>SimpleUrlAuthenticationFailureHandler</code> 或者实现 <code>AuthenticationFailureHandler</code>。</p>
<h5 id="emsp-emsp-8-自定义UsernamePasswordAuthenticationFilter"><a href="#emsp-emsp-8-自定义UsernamePasswordAuthenticationFilter" class="headerlink" title="&emsp;&emsp;8.自定义UsernamePasswordAuthenticationFilter"></a>&emsp;&emsp;8.自定义UsernamePasswordAuthenticationFilter</h5><p>&emsp;&emsp;我们自定义<code>UsernamePasswordAuthenticationFilter</code>可以极大提高我们Security的灵活性（比如添加验证验证码是否正确的功能）。我们直接继承<code>UsernamePasswordAuthenticationFilter</code>，然后在配置类中初始化这个过滤器，给这个过滤器添加登录失败处理器，登录成功处理器，登录管理器，登录请求url 。</p>
<h5 id="emsp-emsp-示例代码"><a href="#emsp-emsp-示例代码" class="headerlink" title="&emsp;&emsp;示例代码"></a>&emsp;&emsp;示例代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化过滤器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">MyUsernamePasswordAuthenticationFilte <span class="title">getAuthenticationFilter</span><span class="params">()</span></span>&#123;	</span><br><span class="line">    MyUsernamePasswordAuthenticationFilter myUsernamePasswordAuthenticationFilter = <span class="keyword">new</span> MyUsernamePasswordAuthenticationFilter(redisService);	</span><br><span class="line">    myUsernamePasswordAuthenticationFilter.setAuthenticationFailureHandler(<span class="keyword">new</span> MyUrlAuthenticationFailureHandler());	</span><br><span class="line">    myUsernamePasswordAuthenticationFilter.setAuthenticationSuccessHandler(<span class="keyword">new</span> MyAuthenticationSuccessHandler());	</span><br><span class="line">    myUsernamePasswordAuthenticationFilter.setFilterProcessesUrl(<span class="string">&quot;/sign_in&quot;</span>);	</span><br><span class="line">    myUsernamePasswordAuthenticationFilter.setAuthenticationManager(getAuthenticationManager());	</span><br><span class="line">    <span class="keyword">return</span> myUsernamePasswordAuthenticationFilter;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加到配置</span><br><span class="line">http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure>

<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>&emsp;&emsp;对于Security的扩展配置关键在于<code>configure(HttpSecurityhttp)</code>方法；扩展认证方式可以自定义<code>authenticationManager</code>并加入自己验证器，在验证器中抛出异常不会终止验证流程；扩展鉴权方式可以自定义<code>accessDecisionManager</code>然后添加自己的投票器并绑定到对应的url（url 匹配方式为 ant）上，投票器<code>vote(Authenticationauthentication</code>,<code>FilterInvocationfi</code>,<code>Collection&lt;ConfigAttribute&gt;attributes) </code>方法返回值为三种：-1 0 1，分别表示反对弃权赞成。</p>
<p>&emsp;&emsp;对于token认证的校验方式，可以暴露一个获取的接口，或者重写<code>UsernamePasswordAuthenticationFilter</code>过滤器和扩展登录成功处理器来获取token，然后在<code>LogoutFilter</code>之后添加一个自定义过滤器，用于校验和填充<code>SecurityContextHolder</code>。</p>
<p>&emsp;&emsp;另外，Security的处理器大部分都是重定向的，我们的项目如果是前后端分离的话，我们希望无论什么情况都返回json,那么就需要重写各个处理器了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yeqiu001.github.io/2021/03/02/SpringSecurity%E5%8E%9F%E7%90%86/" data-id="cknwys56r0008n2eug33wa25n" data-title="SpringSecurity原理" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-security/" rel="tag">spring security</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Security/">Spring Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Springboot/">Springboot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sql/">Sql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E8%AE%A1%E5%88%92/">日常计划</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Annotation/" rel="tag">Annotation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gson/" rel="tag">Gson</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hystrix/" rel="tag">Hystrix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Index/" rel="tag">Index</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ribbon/" rel="tag">Ribbon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ScheduledTask/" rel="tag">ScheduledTask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Security/" rel="tag">Spring Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Springboot/" rel="tag">Springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sql/" rel="tag">Sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Transactional/" rel="tag">Transactional</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/demo/" rel="tag">demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-security/" rel="tag">spring security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/subtree/" rel="tag">subtree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/target/" rel="tag">target</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Annotation/" style="font-size: 10px;">Annotation</a> <a href="/tags/Gson/" style="font-size: 10px;">Gson</a> <a href="/tags/Hystrix/" style="font-size: 10px;">Hystrix</a> <a href="/tags/Index/" style="font-size: 10px;">Index</a> <a href="/tags/JAVA/" style="font-size: 10px;">JAVA</a> <a href="/tags/Ribbon/" style="font-size: 10px;">Ribbon</a> <a href="/tags/ScheduledTask/" style="font-size: 10px;">ScheduledTask</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/Spring-Security/" style="font-size: 10px;">Spring Security</a> <a href="/tags/SpringCloud/" style="font-size: 20px;">SpringCloud</a> <a href="/tags/Springboot/" style="font-size: 10px;">Springboot</a> <a href="/tags/Sql/" style="font-size: 10px;">Sql</a> <a href="/tags/Transactional/" style="font-size: 10px;">Transactional</a> <a href="/tags/demo/" style="font-size: 10px;">demo</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/spring-security/" style="font-size: 10px;">spring security</a> <a href="/tags/subtree/" style="font-size: 10px;">subtree</a> <a href="/tags/target/" style="font-size: 10px;">target</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/19/SpringBoot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/">SpringBoot定时任务和异步线程池</a>
          </li>
        
          <li>
            <a href="/2021/04/15/subtree%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/">Git subtree实现总项目与子项目间双向同步</a>
          </li>
        
          <li>
            <a href="/2021/04/09/Gson%E8%BD%AC%E6%8D%A2int%E5%8F%98%E4%B8%BADouble%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/">Gson转换int变为Double问题解决</a>
          </li>
        
          <li>
            <a href="/2021/04/06/Hystrix%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/">SpringCloud组件：Hystrix容错保护原理及配置</a>
          </li>
        
          <li>
            <a href="/2021/04/02/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/">索引失效</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 YeQiu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>